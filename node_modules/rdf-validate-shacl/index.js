import factory from './src/defaultEnv.js';
import { prepareNamespaces } from './src/namespaces.js';
import ShapesGraph from './src/shapes-graph.js';
import ValidationEngine from './src/validation-engine.js';
/**
 * Validates RDF data based on a set of RDF shapes.
 */
class SHACLValidator {
    /**
     * @param shapes - Dataset containing the SHACL shapes for validation
     * @param {object} [options] - Validator options
     */
    constructor(shapes, options) {
        options = options || {};
        this.factory = options.factory || factory;
        this.ns = prepareNamespaces(this.factory);
        this.allowNamedNodeInList = options.allowNamedNodeInList === undefined ? false : options.allowNamedNodeInList;
        const dataset = this.factory.dataset([...shapes]);
        this.$shapes = this.factory.clownface({ dataset });
        this.$data = this.factory.clownface();
        this.shapesGraph = new ShapesGraph(this);
        this.validationEngine = new ValidationEngine(this, options);
        this.depth = 0;
    }
    /**
     * Validates the provided data graph against the provided shapes graph
     */
    validate(dataGraph) {
        this.setDataGraph(dataGraph);
        this.validationEngine.validateAll(this.$data);
        return this.validationEngine.getReport();
    }
    /**
     * Validates the provided focus node against the provided shape
     */
    validateNode(dataGraph, focusNode, shapeNode) {
        this.setDataGraph(dataGraph);
        this.nodeConformsToShape(focusNode, shapeNode, this.validationEngine);
        return this.validationEngine.getReport();
    }
    setDataGraph(dataGraph) {
        if ('dataset' in dataGraph) {
            this.$data = dataGraph;
        }
        else {
            this.$data = this.factory.clownface({ dataset: dataGraph });
        }
    }
    /**
     * Exposed to be available from validation functions as `SHACL.nodeConformsToShape`
     */
    nodeConformsToShape(focusNode, shapeNode, propertyPathOrEngine) {
        let engine;
        let shape = this.shapesGraph?.getShape(shapeNode);
        if (propertyPathOrEngine && 'termType' in propertyPathOrEngine) {
            engine = this.validationEngine.clone({
                recordErrorsLevel: this.validationEngine.recordErrorsLevel,
            });
            shape = shape.overridePath(propertyPathOrEngine);
        }
        else if (propertyPathOrEngine && 'clone' in propertyPathOrEngine) {
            engine = propertyPathOrEngine;
        }
        else {
            engine = this.validationEngine.clone();
        }
        try {
            this.depth++;
            const foundViolations = engine.validateNodeAgainstShape(focusNode, shape, this.$data);
            return !foundViolations;
        }
        finally {
            this.depth--;
        }
    }
    validateNodeAgainstShape(focusNode, shapeNode) {
        return this.nodeConformsToShape(focusNode, shapeNode, this.validationEngine);
    }
}
export default SHACLValidator;
