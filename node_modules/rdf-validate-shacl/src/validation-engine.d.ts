import type { AnyPointer, GraphPointer } from 'clownface';
import type { Literal, Term } from '@rdfjs/types';
import type SHACLValidator from '../index.js';
import ValidationReport from './validation-report.js';
import type { Constraint, Shape } from './shapes-graph.js';
import type { Environment } from './defaultEnv.js';
import type { ShaclPropertyPath } from './property-path.js';
export type ValidationResult = {
    path?: Term;
    value?: Term | null;
    message?: string;
};
export type ValidationFunction = (context: SHACLValidator, focusNode: Term, valueNode: Term, constraint: Constraint) => ValidationResult[] | string[] | boolean | void;
type Options = {
    propertyPath?: ShaclPropertyPath;
    recordErrorsLevel?: number;
    maxErrors?: number;
    maxNodeChecks?: number;
    nestedResults?: Record<string, GraphPointer[]>;
};
declare class ValidationEngine {
    context: SHACLValidator;
    factory: Environment;
    maxErrors: number | undefined;
    maxNodeChecks: number;
    recordErrorsLevel: number;
    violationsCount: number;
    validationError: Error | null;
    nestedResults: Record<string, GraphPointer[]>;
    nodeCheckCounters: Record<string, number>;
    reportPointer: GraphPointer;
    constructor(context: SHACLValidator, options: Options);
    clone({ recordErrorsLevel }?: Options): ValidationEngine;
    initReport(): void;
    /**
     * Validates the data graph against the shapes graph
     */
    validateAll(dataGraph: AnyPointer): boolean;
    /**
     * Returns true if any violation has been found
     */
    validateNodeAgainstShape(focusNode: Term, shape: Shape, dataGraph: AnyPointer): boolean;
    validateNodeAgainstConstraint(focusNode: Term, valueNodes: Term[], constraint: Constraint, dataGraph: AnyPointer): boolean;
    validateValueNodeAgainstConstraint(focusNode: Term, valueNode: Term | null, constraint: Constraint): boolean;
    maxErrorsReached(): boolean;
    getReport(): ValidationReport;
    /**
     * Creates all the validation result nodes and messages for the result of applying the validation logic
     * of a constraints against a node.
     * Result passed as the first argument can be false, a resultMessage or a validation result object.
     * If none of these values is passed no error result or error message will be created.
     */
    createResultFromObject(validationResult: void | undefined | boolean | string | ValidationResult, constraint: Constraint, focusNode: Term, valueNode: Term | null): GraphPointer;
    /**
     * Validators can return a boolean, a string (message) or a validation result object.
     * This function normalizes all of them as a validation result object.
     * @returns null if validation was successful.
     */
    normalizeValidationResult(validationResult: void | undefined | boolean | string | ValidationResult, valueNode: Term | null): ValidationResult | null;
    /**
     * Creates a new BlankNode holding the SHACL validation result, adding the default
     * properties for the constraint, focused node and value node
     */
    createResult(constraint: Constraint, focusNode: Term): GraphPointer;
    copyNestedStructure(subject: Term, result: GraphPointer): void;
    copySourceShapeStructure(shape: Shape, result: GraphPointer): void;
    /**
     * Creates a result message from the validation result and the message pattern in the constraint
     */
    createResultMessages(validationResult: ValidationResult, constraint: Constraint): Literal[];
}
export default ValidationEngine;
