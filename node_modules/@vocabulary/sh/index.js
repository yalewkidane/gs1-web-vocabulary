/* This file was automatically generated. Do not edit by hand. */
export default ({ factory }) => {
    const f = factory;
    const ns1 = 'http://www.w3.org/ns/shacl#';
    const ns2 = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
    const ns3 = 'http://www.w3.org/2002/07/owl#';
    const ns4 = 'http://www.w3.org/2000/01/rdf-schema#';
    const ns5 = 'http://www.w3.org/ns/shacl-shacl#';
    const ns6 = 'http://www.w3.org/2001/XMLSchema#';
    const ns7 = 'http://datashapes.org/dash#';
    const blankNodes = [];
    for (let i = 0; i < 76; i++) {
        blankNodes.push(f.blankNode());
    }
    return [
        f.quad(f.namedNode(ns1), f.namedNode(`${ns2}type`), f.namedNode(`${ns3}Ontology`), f.namedNode(ns1)),
        f.quad(f.namedNode(ns1), f.namedNode(`${ns4}comment`), f.literal('This vocabulary defines terms used in SHACL, the W3C Shapes Constraint Language.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(ns1), f.namedNode(`${ns4}label`), f.literal('W3C Shapes Constraint Language (SHACL) Vocabulary', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(ns1), f.namedNode(`${ns1}declare`), blankNodes[0], f.namedNode(ns1)),
        f.quad(f.namedNode(ns1), f.namedNode(`${ns1}suggestedShapesGraph`), f.namedNode(ns5), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AbstractResult`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AbstractResult`), f.namedNode(`${ns4}comment`), f.literal('The base class of validation results, typically not instantiated directly.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AbstractResult`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AbstractResult`), f.namedNode(`${ns4}label`), f.literal('Abstract result', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AbstractResult`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AndConstraintComponent-and`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AndConstraintComponent-and`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AndConstraintComponent-and`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}and`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AndConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AndConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to test whether a value node conforms to all members of a provided list of shapes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AndConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AndConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('And constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}AndConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}AndConstraintComponent-and`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}BlankNode`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeKind`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}BlankNode`), f.namedNode(`${ns4}comment`), f.literal('The node kind of all blank nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}BlankNode`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}BlankNode`), f.namedNode(`${ns4}label`), f.literal('Blank node', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}BlankNodeOrIRI`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeKind`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}BlankNodeOrIRI`), f.namedNode(`${ns4}comment`), f.literal('The node kind of all blank nodes or IRIs.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}BlankNodeOrIRI`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}BlankNodeOrIRI`), f.namedNode(`${ns4}label`), f.literal('Blank node or IRI', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}BlankNodeOrLiteral`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeKind`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}BlankNodeOrLiteral`), f.namedNode(`${ns4}comment`), f.literal('The node kind of all blank nodes or literals.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}BlankNodeOrLiteral`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}BlankNodeOrLiteral`), f.namedNode(`${ns4}label`), f.literal('Blank node or literal', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClassConstraintComponent-class`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClassConstraintComponent-class`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClassConstraintComponent-class`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}IRI`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClassConstraintComponent-class`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClassConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClassConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that each value node is an instance of a given type.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClassConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClassConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Class constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClassConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}ClassConstraintComponent-class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent-closed`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent-closed`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent-closed`), f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}boolean`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent-closed`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}closed`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent-ignoredProperties`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent-ignoredProperties`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent-ignoredProperties`), f.namedNode(`${ns1}optional`), f.literal('true', f.namedNode(`${ns6}boolean`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent-ignoredProperties`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}ignoredProperties`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to indicate that focus nodes must only have values for those properties that have been explicitly enumerated via sh:property/sh:path.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Closed constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}ClosedConstraintComponent-closed`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ClosedConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}ClosedConstraintComponent-ignoredProperties`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('The class of constraint components.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Parameterizable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}CountExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}CountExpression`), f.namedNode(`${ns4}comment`), f.literal('A count expression is a blank node with exactly one value for the property sh:count which is a well-formed node expression.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}CountExpression`), f.namedNode(`${ns4}label`), f.literal('Count Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}CountExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}CountExpression`), f.namedNode(`${ns1}property`), blankNodes[1], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}CountExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}count`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DatatypeConstraintComponent-datatype`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DatatypeConstraintComponent-datatype`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DatatypeConstraintComponent-datatype`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DatatypeConstraintComponent-datatype`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}IRI`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DatatypeConstraintComponent-datatype`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}datatype`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DatatypeConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DatatypeConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to restrict the datatype of all value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DatatypeConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DatatypeConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Datatype constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DatatypeConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}DatatypeConstraintComponent-datatype`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DisjointConstraintComponent-disjoint`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DisjointConstraintComponent-disjoint`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DisjointConstraintComponent-disjoint`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}IRI`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DisjointConstraintComponent-disjoint`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}disjoint`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DisjointConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DisjointConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that the set of value nodes is disjoint with the the set of nodes that have the focus node as subject and the value of a given property as predicate.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DisjointConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DisjointConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Disjoint constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DisjointConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}DisjointConstraintComponent-disjoint`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DistinctExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DistinctExpression`), f.namedNode(`${ns4}comment`), f.literal('A distinct expression is a blank node with exactly one value for the property sh:distinct which is a well-formed node expression.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DistinctExpression`), f.namedNode(`${ns4}label`), f.literal('Distinct Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DistinctExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DistinctExpression`), f.namedNode(`${ns1}property`), blankNodes[2], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}DistinctExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}distinct`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}EqualsConstraintComponent-equals`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}EqualsConstraintComponent-equals`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}EqualsConstraintComponent-equals`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}IRI`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}EqualsConstraintComponent-equals`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}equals`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}EqualsConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}EqualsConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that the set of value nodes is equal to the set of nodes that have the focus node as subject and the value of a given property as predicate.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}EqualsConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}EqualsConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Equals constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}EqualsConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}EqualsConstraintComponent-equals`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExistsExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExistsExpression`), f.namedNode(`${ns4}comment`), f.literal('An exists expression is a blank node with exactly one value for sh:exists (which is a well-formed shape).'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExistsExpression`), f.namedNode(`${ns4}label`), f.literal('Exists Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExistsExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExistsExpression`), f.namedNode(`${ns1}property`), blankNodes[3], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExistsExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}exists`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExpressionConstraintComponent-expression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExpressionConstraintComponent-expression`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExpressionConstraintComponent-expression`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}expression`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExpressionConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExpressionConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that a given node expression produces true for all value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExpressionConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExpressionConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Expression constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ExpressionConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}ExpressionConstraintComponent-expression`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FilterShapeExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FilterShapeExpression`), f.namedNode(`${ns4}comment`), f.literal('A filter shape expression is a blank node with exactly one value for sh:filterShape (which is a well-formed shape) and at most one value for sh:nodes (which is a well-formed node expression).'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FilterShapeExpression`), f.namedNode(`${ns4}label`), f.literal('Filter Shape Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FilterShapeExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FilterShapeExpression`), f.namedNode(`${ns1}property`), blankNodes[4], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FilterShapeExpression`), f.namedNode(`${ns1}property`), blankNodes[5], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FilterShapeExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}filterShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FocusNodeOrConstantTermExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FocusNodeOrConstantTermExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}IRIOrLiteral`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Function`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Function`), f.namedNode(`${ns4}comment`), f.literal('The class of SHACL functions.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Function`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Function`), f.namedNode(`${ns4}label`), f.literal('Function', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Function`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Parameterizable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FunctionExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FunctionExpression`), f.namedNode(`${ns4}comment`), f.literal('A function expression is a blank node that does not fulfill any of the syntax rules of the other node expression types and which is the subject of exactly one triple T where the object is a well-formed SHACL list, and each member of that list is a well-formed node expression.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FunctionExpression`), f.namedNode(`${ns4}label`), f.literal('Function Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}FunctionExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}GroupConcatExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}GroupConcatExpression`), f.namedNode(`${ns4}comment`), f.literal('A group concat expression is a blank node with exactly one value for the property sh:groupConcat which is a well-formed node expression. A group concat expression can have a single value for the property sh:separator which is literal with datatype xsd:string.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}GroupConcatExpression`), f.namedNode(`${ns4}label`), f.literal('Group Concat Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}GroupConcatExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}GroupConcatExpression`), f.namedNode(`${ns1}property`), blankNodes[6], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}GroupConcatExpression`), f.namedNode(`${ns1}property`), blankNodes[7], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}GroupConcatExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}groupConcat`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}HasValueConstraintComponent-hasValue`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}HasValueConstraintComponent-hasValue`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}HasValueConstraintComponent-hasValue`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}hasValue`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}HasValueConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}HasValueConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that one of the value nodes is a given RDF node.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}HasValueConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}HasValueConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Has-value constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}HasValueConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}HasValueConstraintComponent-hasValue`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IRI`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeKind`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IRI`), f.namedNode(`${ns4}comment`), f.literal('The node kind of all IRIs.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IRI`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IRI`), f.namedNode(`${ns4}label`), f.literal('IRI', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IRIOrLiteral`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeKind`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IRIOrLiteral`), f.namedNode(`${ns4}comment`), f.literal('The node kind of all IRIs or literals.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IRIOrLiteral`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IRIOrLiteral`), f.namedNode(`${ns4}label`), f.literal('IRI or literal', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IfExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IfExpression`), f.namedNode(`${ns4}comment`), f.literal('An if expression is a blank node with exactly one value for sh:if (which is a well-formed node expression), at most one value for sh:then (which is a well-formed node expression) and at most one value for sh:else (which is a well-formed node expression).'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IfExpression`), f.namedNode(`${ns4}label`), f.literal('If Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IfExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IfExpression`), f.namedNode(`${ns1}property`), blankNodes[8], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IfExpression`), f.namedNode(`${ns1}property`), blankNodes[9], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IfExpression`), f.namedNode(`${ns1}property`), blankNodes[10], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IfExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}else`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IfExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}if`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IfExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}then`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}InConstraintComponent-in`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}InConstraintComponent-in`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}InConstraintComponent-in`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}InConstraintComponent-in`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}in`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}InConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}InConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to exclusively enumerate the permitted value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}InConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}InConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('In constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}InConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}InConstraintComponent-in`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Info`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Severity`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Info`), f.namedNode(`${ns4}comment`), f.literal('The severity for an informational validation result.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Info`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Info`), f.namedNode(`${ns4}label`), f.literal('Info', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IntersectionExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IntersectionExpression`), f.namedNode(`${ns4}comment`), f.literal('An intersection expression is a blank node with exactly one value for the property sh:intersection which is a well-formed SHACL list with at least two members (which are well-formed node expressions).'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IntersectionExpression`), f.namedNode(`${ns4}label`), f.literal('Intersection Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IntersectionExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IntersectionExpression`), f.namedNode(`${ns1}property`), blankNodes[11], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}IntersectionExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}intersection`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraint-js`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraint-js`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraint-js`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}js`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraint`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraint`), f.namedNode(`${ns4}comment`), f.literal('The class of constraints backed by a JavaScript function.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraint`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraint`), f.namedNode(`${ns4}label`), f.literal('JavaScript-based constraint', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraint`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}JSExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component with the parameter sh:js linking to a sh:JSConstraint containing a sh:script.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('JavaScript constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}JSConstraint-js`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSExecutable`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSExecutable`), f.namedNode(`${ns4}comment`), f.literal('Abstract base class of resources that declare an executable JavaScript.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSExecutable`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSExecutable`), f.namedNode(`${ns4}label`), f.literal('JavaScript executable', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSExecutable`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSFunction`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSFunction`), f.namedNode(`${ns4}comment`), f.literal('The class of SHACL functions that execute a JavaScript function when called.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSFunction`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSFunction`), f.namedNode(`${ns4}label`), f.literal('JavaScript function', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSFunction`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Function`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSFunction`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}JSExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSLibrary`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSLibrary`), f.namedNode(`${ns4}comment`), f.literal('Represents a JavaScript library, typically identified by one or more URLs of files to include.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSLibrary`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSLibrary`), f.namedNode(`${ns4}label`), f.literal('JavaScript library', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSLibrary`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSRule`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSRule`), f.namedNode(`${ns4}comment`), f.literal('The class of SHACL rules expressed using JavaScript.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSRule`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSRule`), f.namedNode(`${ns4}label`), f.literal('JavaScript rule', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSRule`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}JSExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSRule`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Rule`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSTarget`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSTarget`), f.namedNode(`${ns4}comment`), f.literal('The class of targets that are based on JavaScript functions.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSTarget`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSTarget`), f.namedNode(`${ns4}label`), f.literal('JavaScript target', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSTarget`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}JSExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSTarget`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Target`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSTargetType`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSTargetType`), f.namedNode(`${ns4}comment`), f.literal('The (meta) class for parameterizable targets that are based on JavaScript functions.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSTargetType`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSTargetType`), f.namedNode(`${ns4}label`), f.literal('JavaScript target type', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSTargetType`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}JSExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSTargetType`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}TargetType`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSValidator`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSValidator`), f.namedNode(`${ns4}comment`), f.literal('A SHACL validator based on JavaScript. This can be used to declare SHACL constraint components that perform JavaScript-based validation when used.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSValidator`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSValidator`), f.namedNode(`${ns4}label`), f.literal('JavaScript validator', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSValidator`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}JSExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}JSValidator`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Validator`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LanguageInConstraintComponent-languageIn`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LanguageInConstraintComponent-languageIn`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LanguageInConstraintComponent-languageIn`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LanguageInConstraintComponent-languageIn`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}languageIn`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LanguageInConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LanguageInConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to enumerate language tags that all value nodes must have.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LanguageInConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LanguageInConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Language-in constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LanguageInConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}LanguageInConstraintComponent-languageIn`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanConstraintComponent-lessThan`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanConstraintComponent-lessThan`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanConstraintComponent-lessThan`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}IRI`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanConstraintComponent-lessThan`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}lessThan`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that each value node is smaller than all the nodes that have the focus node as subject and the value of a given property as predicate.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Less-than constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}LessThanConstraintComponent-lessThan`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanOrEqualsConstraintComponent-lessThanOrEquals`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanOrEqualsConstraintComponent-lessThanOrEquals`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanOrEqualsConstraintComponent-lessThanOrEquals`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}IRI`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanOrEqualsConstraintComponent-lessThanOrEquals`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}lessThanOrEquals`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanOrEqualsConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanOrEqualsConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that every value node is smaller than all the nodes that have the focus node as subject and the value of a given property as predicate.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanOrEqualsConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanOrEqualsConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('less-than-or-equals constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LessThanOrEqualsConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}LessThanOrEqualsConstraintComponent-lessThanOrEquals`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LimitExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LimitExpression`), f.namedNode(`${ns4}comment`), f.literal('A limit expression is a blank node with exactly one value for the property sh:limit which is a literal with datatype xsd:integer and with exactly one value for the property sh:nodes which is a well-formed node expression.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LimitExpression`), f.namedNode(`${ns4}label`), f.literal('Limit Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LimitExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LimitExpression`), f.namedNode(`${ns1}property`), blankNodes[12], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LimitExpression`), f.namedNode(`${ns1}property`), blankNodes[13], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}LimitExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}limit`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Literal`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeKind`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Literal`), f.namedNode(`${ns4}comment`), f.literal('The node kind of all literals.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Literal`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Literal`), f.namedNode(`${ns4}label`), f.literal('Literal', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxCountConstraintComponent-maxCount`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxCountConstraintComponent-maxCount`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxCountConstraintComponent-maxCount`), f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxCountConstraintComponent-maxCount`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxCountConstraintComponent-maxCount`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}maxCount`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxCountConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxCountConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to restrict the maximum number of value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxCountConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxCountConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Max-count constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxCountConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}MaxCountConstraintComponent-maxCount`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExclusiveConstraintComponent-maxExclusive`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExclusiveConstraintComponent-maxExclusive`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExclusiveConstraintComponent-maxExclusive`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExclusiveConstraintComponent-maxExclusive`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}Literal`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExclusiveConstraintComponent-maxExclusive`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}maxExclusive`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExclusiveConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExclusiveConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to restrict the range of value nodes with a maximum exclusive value.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExclusiveConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExclusiveConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Max-exclusive constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExclusiveConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}MaxExclusiveConstraintComponent-maxExclusive`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExpression`), f.namedNode(`${ns4}comment`), f.literal('A max expression is a blank node with exactly one value for the property sh:max which is a well-formed node expression.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExpression`), f.namedNode(`${ns4}label`), f.literal('Max Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExpression`), f.namedNode(`${ns1}property`), blankNodes[14], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}max`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxInclusiveConstraintComponent-maxInclusive`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxInclusiveConstraintComponent-maxInclusive`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxInclusiveConstraintComponent-maxInclusive`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxInclusiveConstraintComponent-maxInclusive`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}Literal`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxInclusiveConstraintComponent-maxInclusive`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}maxInclusive`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxInclusiveConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxInclusiveConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to restrict the range of value nodes with a maximum inclusive value.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxInclusiveConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxInclusiveConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Max-inclusive constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxInclusiveConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}MaxInclusiveConstraintComponent-maxInclusive`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxLengthConstraintComponent-maxLength`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxLengthConstraintComponent-maxLength`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxLengthConstraintComponent-maxLength`), f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxLengthConstraintComponent-maxLength`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxLengthConstraintComponent-maxLength`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}maxLength`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxLengthConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxLengthConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to restrict the maximum string length of value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxLengthConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxLengthConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Max-length constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MaxLengthConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}MaxLengthConstraintComponent-maxLength`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinCountConstraintComponent-minCount`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinCountConstraintComponent-minCount`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinCountConstraintComponent-minCount`), f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinCountConstraintComponent-minCount`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinCountConstraintComponent-minCount`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}minCount`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinCountConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinCountConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to restrict the minimum number of value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinCountConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinCountConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Min-count constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinCountConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}MinCountConstraintComponent-minCount`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExclusiveConstraintComponent-minExclusive`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExclusiveConstraintComponent-minExclusive`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExclusiveConstraintComponent-minExclusive`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExclusiveConstraintComponent-minExclusive`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}Literal`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExclusiveConstraintComponent-minExclusive`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}minExclusive`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExclusiveConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExclusiveConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to restrict the range of value nodes with a minimum exclusive value.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExclusiveConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExclusiveConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Min-exclusive constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExclusiveConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}MinExclusiveConstraintComponent-minExclusive`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExpression`), f.namedNode(`${ns4}comment`), f.literal('A min expression is a blank node with exactly one value for the property sh:min which is a well-formed node expression.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExpression`), f.namedNode(`${ns4}label`), f.literal('Min Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExpression`), f.namedNode(`${ns1}property`), blankNodes[15], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}min`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinInclusiveConstraintComponent-minInclusive`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinInclusiveConstraintComponent-minInclusive`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinInclusiveConstraintComponent-minInclusive`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinInclusiveConstraintComponent-minInclusive`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}Literal`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinInclusiveConstraintComponent-minInclusive`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}minInclusive`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinInclusiveConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinInclusiveConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to restrict the range of value nodes with a minimum inclusive value.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinInclusiveConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinInclusiveConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Min-inclusive constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinInclusiveConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}MinInclusiveConstraintComponent-minInclusive`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinLengthConstraintComponent-minLength`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinLengthConstraintComponent-minLength`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinLengthConstraintComponent-minLength`), f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinLengthConstraintComponent-minLength`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinLengthConstraintComponent-minLength`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}minLength`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinLengthConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinLengthConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to restrict the minimum string length of value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinLengthConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinLengthConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Min-length constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinLengthConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}MinLengthConstraintComponent-minLength`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinusExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinusExpression`), f.namedNode(`${ns4}comment`), f.literal('A minus expression is a blank node with exactly one value for the property sh:minus which is a well-formed node expression and exactly one value for the property sh:nodes which is a well-formed node expression.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinusExpression`), f.namedNode(`${ns4}label`), f.literal('Minus Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinusExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinusExpression`), f.namedNode(`${ns1}property`), blankNodes[16], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinusExpression`), f.namedNode(`${ns1}property`), blankNodes[17], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}MinusExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}minus`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeConstraintComponent-node`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeConstraintComponent-node`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeConstraintComponent-node`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}node`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that all value nodes conform to the given node shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Node constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}NodeConstraintComponent-node`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeExpression`), f.namedNode(`${ns1}targetObjectsOf`), f.namedNode(`${ns1}expression`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeExpression`), f.namedNode(`${ns1}targetObjectsOf`), f.namedNode(`${ns1}values`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeExpression`), f.namedNode(`${ns1}xone`), blankNodes[18], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKind`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKind`), f.namedNode(`${ns4}comment`), f.literal('The class of all node kinds, including sh:BlankNode, sh:IRI, sh:Literal or the combinations of these: sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral, sh:IRIOrLiteral.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKind`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKind`), f.namedNode(`${ns4}label`), f.literal('Node kind', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKind`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKindConstraintComponent-nodeKind`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKindConstraintComponent-nodeKind`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKindConstraintComponent-nodeKind`), f.namedNode(`${ns1}in`), blankNodes[19], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKindConstraintComponent-nodeKind`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKindConstraintComponent-nodeKind`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}nodeKind`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKindConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKindConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to restrict the RDF node kind of each value node.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKindConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKindConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Node-kind constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeKindConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}NodeKindConstraintComponent-nodeKind`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeShape`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeShape`), f.namedNode(`${ns4}comment`), f.literal('A node shape is a shape that specifies constraint that need to be met with respect to focus nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeShape`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeShape`), f.namedNode(`${ns4}label`), f.literal('Node shape', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NodeShape`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NotConstraintComponent-not`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NotConstraintComponent-not`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NotConstraintComponent-not`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}not`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NotConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NotConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that value nodes do not conform to a given shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NotConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NotConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Not constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}NotConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}NotConstraintComponent-not`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OffsetExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OffsetExpression`), f.namedNode(`${ns4}comment`), f.literal('An offset expression is a blank node with exactly one value for the property sh:offset which is a literal with datatype xsd:integer and with exactly one value for the property sh:nodes which is a well-formed node expression.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OffsetExpression`), f.namedNode(`${ns4}label`), f.literal('Offset Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OffsetExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OffsetExpression`), f.namedNode(`${ns1}property`), blankNodes[20], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OffsetExpression`), f.namedNode(`${ns1}property`), blankNodes[21], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OffsetExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}offset`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrConstraintComponent-or`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrConstraintComponent-or`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrConstraintComponent-or`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}or`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to restrict the value nodes so that they conform to at least one out of several provided shapes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Or constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}OrConstraintComponent-or`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrderByExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrderByExpression`), f.namedNode(`${ns4}comment`), f.literal('An orderBy expression is a blank node with exactly one value for the property sh:orderBy which is a well-formed node expression and with exactly one value for the property sh:nodes which is a well-formed node expression. An orderBy expression can have one value for the property sh:desc which is either true or false.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrderByExpression`), f.namedNode(`${ns4}label`), f.literal('OrderBy Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrderByExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrderByExpression`), f.namedNode(`${ns1}property`), blankNodes[22], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrderByExpression`), f.namedNode(`${ns1}property`), blankNodes[23], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrderByExpression`), f.namedNode(`${ns1}property`), blankNodes[24], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}OrderByExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}orderBy`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Parameter`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Parameter`), f.namedNode(`${ns4}comment`), f.literal('The class of parameter declarations, consisting of a path predicate and (possibly) information about allowed value type, cardinality and other characteristics.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Parameter`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Parameter`), f.namedNode(`${ns4}label`), f.literal('Parameter', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Parameter`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}PropertyShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Parameterizable`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Parameterizable`), f.namedNode(`${ns4}comment`), f.literal('Superclass of components that can take parameters, especially functions and constraint components.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Parameterizable`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Parameterizable`), f.namedNode(`${ns4}label`), f.literal('Parameterizable', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Parameterizable`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PathExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PathExpression`), f.namedNode(`${ns4}comment`), f.literal('A path expression is a blank node with exactly one value of the property sh:path (which are well-formed property paths) and at most one value for sh:nodes (which is a well-formed node expression).'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PathExpression`), f.namedNode(`${ns4}label`), f.literal('Path Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PathExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PathExpression`), f.namedNode(`${ns1}property`), blankNodes[25], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PathExpression`), f.namedNode(`${ns1}property`), blankNodes[26], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent-flags`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent-flags`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent-flags`), f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent-flags`), f.namedNode(`${ns1}optional`), f.literal('true', f.namedNode(`${ns6}boolean`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent-flags`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}flags`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent-pattern`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent-pattern`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent-pattern`), f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent-pattern`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}pattern`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that every value node matches a given regular expression.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Pattern constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}PatternConstraintComponent-flags`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PatternConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}PatternConstraintComponent-pattern`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PrefixDeclaration`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PrefixDeclaration`), f.namedNode(`${ns4}comment`), f.literal('The class of prefix declarations, consisting of pairs of a prefix with a namespace.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PrefixDeclaration`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PrefixDeclaration`), f.namedNode(`${ns4}label`), f.literal('Prefix declaration', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PrefixDeclaration`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyConstraintComponent-property`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyConstraintComponent-property`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyConstraintComponent-property`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that all value nodes conform to the given property shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Property constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}PropertyConstraintComponent-property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyGroup`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyGroup`), f.namedNode(`${ns4}comment`), f.literal('Instances of this class represent groups of property shapes that belong together.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyGroup`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyGroup`), f.namedNode(`${ns4}label`), f.literal('Property group', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyGroup`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyShape`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyShape`), f.namedNode(`${ns4}comment`), f.literal('A property shape is a shape that specifies constraints on the values of a focus node for a given property or path.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyShape`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyShape`), f.namedNode(`${ns4}label`), f.literal('Property shape', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}PropertyShape`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedMaxCount`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedMaxCount`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedMaxCount`), f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedMaxCount`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}qualifiedMaxCount`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedValueShape`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedValueShape`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedValueShape`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}qualifiedValueShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint`), f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}boolean`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint`), f.namedNode(`${ns1}optional`), f.literal('true', f.namedNode(`${ns6}boolean`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}qualifiedValueShapesDisjoint`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that a specified maximum number of value nodes conforms to a given shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Qualified-max-count constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedMaxCount`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedValueShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedMinCount`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedMinCount`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedMinCount`), f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedMinCount`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}qualifiedMinCount`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedValueShape`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedValueShape`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedValueShape`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}qualifiedValueShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint`), f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}boolean`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint`), f.namedNode(`${ns1}optional`), f.literal('true', f.namedNode(`${ns6}boolean`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}qualifiedValueShapesDisjoint`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to verify that a specified minimum number of value nodes conforms to a given shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Qualified-min-count constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedMinCount`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedValueShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}QualifiedMinCountConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ResultAnnotation`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ResultAnnotation`), f.namedNode(`${ns4}comment`), f.literal('A class of result annotations, which define the rules to derive the values of a given annotation property as extra values for a validation result.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ResultAnnotation`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ResultAnnotation`), f.namedNode(`${ns4}label`), f.literal('Result annotation', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ResultAnnotation`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Rule`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Rule`), f.namedNode(`${ns4}comment`), f.literal('The class of SHACL rules. Never instantiated directly.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Rule`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Rule`), f.namedNode(`${ns4}label`), f.literal('Rule', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Rule`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExecutable`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExecutable`), f.namedNode(`${ns4}comment`), f.literal('The class of SPARQL executables that are based on an ASK query.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExecutable`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExecutable`), f.namedNode(`${ns4}label`), f.literal('SPARQL ASK executable', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExecutable`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExpression`), f.namedNode(`${ns4}comment`), f.literal('A SPARQL ASK expression is a blank node with exactly one value for the property sh:ask which is string literal. The blank node may have values for the property sh:prefixes and these values are IRIs or blank nodes. Using the values of sh:prefixes as defined by 5.2.1 Prefix Declarations for SPARQL Queries, the value of sh:ask must be valid SPARQL 1.1 ASK query. The blank node may also have exactly one value for the property sh:nodes which is a well-formed node expression.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExpression`), f.namedNode(`${ns4}label`), f.literal('SPARQL ASK Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExpression`), f.namedNode(`${ns1}property`), blankNodes[27], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExpression`), f.namedNode(`${ns1}property`), blankNodes[28], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExpression`), f.namedNode(`${ns1}property`), blankNodes[29], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}ask`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskValidator`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskValidator`), f.namedNode(`${ns4}comment`), f.literal('The class of validators based on SPARQL ASK queries. The queries are evaluated for each value node and are supposed to return true if the given node conforms.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskValidator`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskValidator`), f.namedNode(`${ns4}label`), f.literal('SPARQL ASK validator', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskValidator`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLAskExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLAskValidator`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Validator`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraint`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraint`), f.namedNode(`${ns4}comment`), f.literal('The class of constraints based on SPARQL SELECT queries.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraint`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraint`), f.namedNode(`${ns4}label`), f.literal('SPARQL constraint', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraint`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLSelectExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraintComponent-sparql`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraintComponent-sparql`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraintComponent-sparql`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}sparql`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to define constraints based on SPARQL queries.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('SPARQL constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}SPARQLConstraintComponent-sparql`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstructExecutable`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstructExecutable`), f.namedNode(`${ns4}comment`), f.literal('The class of SPARQL executables that are based on a CONSTRUCT query.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstructExecutable`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstructExecutable`), f.namedNode(`${ns4}label`), f.literal('SPARQL CONSTRUCT executable', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLConstructExecutable`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLExecutable`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLExecutable`), f.namedNode(`${ns4}comment`), f.literal('The class of resources that encapsulate a SPARQL query.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLExecutable`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLExecutable`), f.namedNode(`${ns4}label`), f.literal('SPARQL executable', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLExecutable`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLFunction`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLFunction`), f.namedNode(`${ns4}comment`), f.literal('A function backed by a SPARQL query - either ASK or SELECT.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLFunction`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLFunction`), f.namedNode(`${ns4}label`), f.literal('SPARQL function', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLFunction`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Function`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLFunction`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLAskExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLFunction`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLSelectExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLRule`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLRule`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLRule`), f.namedNode(`${ns4}comment`), f.literal('The class of SHACL rules based on SPARQL CONSTRUCT queries.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLRule`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLRule`), f.namedNode(`${ns4}label`), f.literal('SPARQL CONSTRUCT rule', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLRule`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Rule`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLRule`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLConstructExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLRule`), f.namedNode(`${ns1}property`), blankNodes[30], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLRule`), f.namedNode(`${ns1}property`), blankNodes[31], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExecutable`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExecutable`), f.namedNode(`${ns4}comment`), f.literal('The class of SPARQL executables based on a SELECT query.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExecutable`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExecutable`), f.namedNode(`${ns4}label`), f.literal('SPARQL SELECT executable', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExecutable`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExpression`), f.namedNode(`${ns4}comment`), f.literal('A SPARQL SELECT expression is a blank node with exactly one value for the property sh:select which is string literal. The blank node may have values for the property sh:prefixes and these values are IRIs or blank nodes. Using the values of sh:prefixes as defined by 5.2.1 Prefix Declarations for SPARQL Queries, the value of sh:select must be valid SPARQL 1.1 SELECT query with exactly one result variable. The blank node may also have exactly one value for the property sh:nodes which is a well-formed node expression.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExpression`), f.namedNode(`${ns4}label`), f.literal('SPARQL SELECT Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExpression`), f.namedNode(`${ns1}property`), blankNodes[32], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExpression`), f.namedNode(`${ns1}property`), blankNodes[33], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExpression`), f.namedNode(`${ns1}property`), blankNodes[34], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}select`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectValidator`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectValidator`), f.namedNode(`${ns4}comment`), f.literal('The class of validators based on SPARQL SELECT queries. The queries are evaluated for each focus node and are supposed to produce bindings for all focus nodes that do not conform.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectValidator`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectValidator`), f.namedNode(`${ns4}label`), f.literal('SPARQL SELECT validator', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectValidator`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLSelectExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLSelectValidator`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Validator`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTarget`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTarget`), f.namedNode(`${ns4}comment`), f.literal('The class of targets that are based on SPARQL queries.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTarget`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTarget`), f.namedNode(`${ns4}label`), f.literal('SPARQL target', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTarget`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLAskExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTarget`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLSelectExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTarget`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Target`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTargetType`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTargetType`), f.namedNode(`${ns4}comment`), f.literal('The (meta) class for parameterizable targets that are based on SPARQL queries.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTargetType`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTargetType`), f.namedNode(`${ns4}label`), f.literal('SPARQL target type', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTargetType`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLAskExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTargetType`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLSelectExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLTargetType`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}TargetType`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLUpdateExecutable`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLUpdateExecutable`), f.namedNode(`${ns4}comment`), f.literal('The class of SPARQL executables based on a SPARQL UPDATE.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLUpdateExecutable`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLUpdateExecutable`), f.namedNode(`${ns4}label`), f.literal('SPARQL UPDATE executable', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SPARQLUpdateExecutable`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}SPARQLExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Severity`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Severity`), f.namedNode(`${ns4}comment`), f.literal('The class of validation result severity levels, including violation and warning levels.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Severity`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Severity`), f.namedNode(`${ns4}label`), f.literal('Severity', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Severity`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Shape`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Shape`), f.namedNode(`${ns4}comment`), f.literal('A shape is a collection of constraints that may be targeted for certain nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Shape`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Shape`), f.namedNode(`${ns4}label`), f.literal('Shape', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Shape`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SumExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SumExpression`), f.namedNode(`${ns4}comment`), f.literal('A sum expression is a blank node with exactly one value for the property sh:sum which is a well-formed node expression.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SumExpression`), f.namedNode(`${ns4}label`), f.literal('Sum Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SumExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SumExpression`), f.namedNode(`${ns1}property`), blankNodes[35], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}SumExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}sum`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Target`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Target`), f.namedNode(`${ns4}comment`), f.literal('The base class of targets such as those based on SPARQL queries.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Target`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Target`), f.namedNode(`${ns4}label`), f.literal('Target', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Target`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TargetType`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TargetType`), f.namedNode(`${ns4}comment`), f.literal('The (meta) class for parameterizable targets.	Instances of this are instantiated as values of the sh:target property.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TargetType`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TargetType`), f.namedNode(`${ns4}label`), f.literal('Target type', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TargetType`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TargetType`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Parameterizable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TripleRule`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TripleRule`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TripleRule`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TripleRule`), f.namedNode(`${ns4}label`), f.literal('A rule based on triple (subject, predicate, object) pattern.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TripleRule`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}Rule`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TripleRule`), f.namedNode(`${ns1}property`), blankNodes[36], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TripleRule`), f.namedNode(`${ns1}property`), blankNodes[37], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}TripleRule`), f.namedNode(`${ns1}property`), blankNodes[38], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UnionExpression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UnionExpression`), f.namedNode(`${ns4}comment`), f.literal('A union expression is a blank node with exactly one value for the property sh:union which is a well-formed SHACL list with at least two members (which are well-formed node expressions).'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UnionExpression`), f.namedNode(`${ns4}label`), f.literal('Union Expression'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UnionExpression`), f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UnionExpression`), f.namedNode(`${ns1}property`), blankNodes[39], f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UnionExpression`), f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns1}union`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UniqueLangConstraintComponent-uniqueLang`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UniqueLangConstraintComponent-uniqueLang`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UniqueLangConstraintComponent-uniqueLang`), f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}boolean`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UniqueLangConstraintComponent-uniqueLang`), f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UniqueLangConstraintComponent-uniqueLang`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}uniqueLang`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UniqueLangConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UniqueLangConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to specify that no pair of value nodes may use the same language tag.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UniqueLangConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UniqueLangConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Unique-languages constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}UniqueLangConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}UniqueLangConstraintComponent-uniqueLang`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ValidationReport`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ValidationReport`), f.namedNode(`${ns4}comment`), f.literal('The class of SHACL validation reports.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ValidationReport`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ValidationReport`), f.namedNode(`${ns4}label`), f.literal('Validation report', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ValidationReport`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ValidationResult`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ValidationResult`), f.namedNode(`${ns4}comment`), f.literal('The class of validation results.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ValidationResult`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ValidationResult`), f.namedNode(`${ns4}label`), f.literal('Validation result', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ValidationResult`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns1}AbstractResult`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Validator`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Validator`), f.namedNode(`${ns4}comment`), f.literal('The class of validators, which provide instructions on how to process a constraint definition. This class serves as base class for the SPARQL-based validators and other possible implementations.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Validator`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Validator`), f.namedNode(`${ns4}label`), f.literal('Validator', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Validator`), f.namedNode(`${ns4}subClassOf`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Violation`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Severity`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Violation`), f.namedNode(`${ns4}comment`), f.literal('The severity for a violation validation result.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Violation`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Violation`), f.namedNode(`${ns4}label`), f.literal('Violation', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Warning`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Severity`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Warning`), f.namedNode(`${ns4}comment`), f.literal('The severity for a warning validation result.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Warning`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}Warning`), f.namedNode(`${ns4}label`), f.literal('Warning', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}XoneConstraintComponent-xone`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}XoneConstraintComponent-xone`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}XoneConstraintComponent-xone`), f.namedNode(`${ns1}path`), f.namedNode(`${ns1}xone`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}XoneConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}XoneConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('A constraint component that can be used to restrict the value nodes so that they conform to exactly one out of several provided shapes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}XoneConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}XoneConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('Exactly one constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}XoneConstraintComponent`), f.namedNode(`${ns1}parameter`), f.namedNode(`${ns1}XoneConstraintComponent-xone`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}alternativePath`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}alternativePath`), f.namedNode(`${ns4}comment`), f.literal('The (single) value of this property must be a list of path elements, representing the elements of alternative paths.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}alternativePath`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}alternativePath`), f.namedNode(`${ns4}label`), f.literal('alternative path', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}alternativePath`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}List`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}and`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}and`), f.namedNode(`${ns4}comment`), f.literal('RDF list of shapes to validate the value nodes against.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}and`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}and`), f.namedNode(`${ns4}label`), f.literal('and', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}and`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}List`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationProperty`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationProperty`), f.namedNode(`${ns4}comment`), f.literal('The annotation property that shall be set.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationProperty`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}ResultAnnotation`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationProperty`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationProperty`), f.namedNode(`${ns4}label`), f.literal('annotation property', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationProperty`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationValue`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationValue`), f.namedNode(`${ns4}comment`), f.literal('The (default) values of the annotation property.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationValue`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}ResultAnnotation`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationValue`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationValue`), f.namedNode(`${ns4}label`), f.literal('annotation value', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationVarName`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationVarName`), f.namedNode(`${ns4}comment`), f.literal('The name of the SPARQL variable from the SELECT clause that shall be used for the values.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationVarName`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}ResultAnnotation`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationVarName`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationVarName`), f.namedNode(`${ns4}label`), f.literal('annotation variable name', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}annotationVarName`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ask`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ask`), f.namedNode(`${ns4}comment`), f.literal('The SPARQL ASK query to execute.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ask`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}SPARQLAskExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ask`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ask`), f.namedNode(`${ns4}label`), f.literal('ask', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ask`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}class`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}class`), f.namedNode(`${ns4}comment`), f.literal('The type that all value nodes must have.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}class`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}class`), f.namedNode(`${ns4}label`), f.literal('class', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}class`), f.namedNode(`${ns4}range`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}closed`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}closed`), f.namedNode(`${ns4}comment`), f.literal('If set to true then the shape is closed.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}closed`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}closed`), f.namedNode(`${ns4}label`), f.literal('closed', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}closed`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}boolean`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}condition`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}condition`), f.namedNode(`${ns4}comment`), f.literal('The shapes that the focus nodes need to conform to before a rule is executed on them.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}condition`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Rule`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}condition`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}condition`), f.namedNode(`${ns4}label`), f.literal('condition', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}condition`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}conforms`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}conforms`), f.namedNode(`${ns4}comment`), f.literal('True if the validation did not produce any validation results, and false otherwise.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}conforms`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}ValidationReport`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}conforms`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}conforms`), f.namedNode(`${ns4}label`), f.literal('conforms', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}conforms`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}boolean`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}construct`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}construct`), f.namedNode(`${ns4}comment`), f.literal('The SPARQL CONSTRUCT query to execute.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}construct`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}SPARQLConstructExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}construct`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}construct`), f.namedNode(`${ns4}label`), f.literal('construct', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}construct`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}count`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}datatype`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}datatype`), f.namedNode(`${ns4}comment`), f.literal('Specifies an RDF datatype that all value nodes must have.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}datatype`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}datatype`), f.namedNode(`${ns4}label`), f.literal('datatype', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}datatype`), f.namedNode(`${ns4}range`), f.namedNode(`${ns4}Datatype`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}deactivated`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}deactivated`), f.namedNode(`${ns4}comment`), f.literal('If set to true then all nodes conform to this.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}deactivated`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}deactivated`), f.namedNode(`${ns4}label`), f.literal('deactivated', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}deactivated`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}boolean`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}declare`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}declare`), f.namedNode(`${ns4}comment`), f.literal('Links a resource with its namespace prefix declarations.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}declare`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns3}Ontology`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}declare`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}declare`), f.namedNode(`${ns4}label`), f.literal('declare', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}declare`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}PrefixDeclaration`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}defaultValue`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}defaultValue`), f.namedNode(`${ns4}comment`), f.literal('A default value for a property, for example for user interface tools to pre-populate input fields.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}defaultValue`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}PropertyShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}defaultValue`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}defaultValue`), f.namedNode(`${ns4}label`), f.literal('default value', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}desc`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}description`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}description`), f.namedNode(`${ns4}comment`), f.literal('Human-readable descriptions for the property in the context of the surrounding shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}description`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}PropertyShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}description`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}description`), f.namedNode(`${ns4}label`), f.literal('description', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}detail`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}detail`), f.namedNode(`${ns4}comment`), f.literal('Links a result with other results that provide more details, for example to describe violations against nested shapes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}detail`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}AbstractResult`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}detail`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}detail`), f.namedNode(`${ns4}label`), f.literal('detail', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}detail`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}AbstractResult`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}disjoint`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}disjoint`), f.namedNode(`${ns4}comment`), f.literal('Specifies a property where the set of values must be disjoint with the value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}disjoint`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}disjoint`), f.namedNode(`${ns4}label`), f.literal('disjoint', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}disjoint`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}distinct`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}else`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}entailment`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}entailment`), f.namedNode(`${ns4}comment`), f.literal('An entailment regime that indicates what kind of inferencing is required by a shapes graph.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}entailment`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns3}Ontology`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}entailment`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}entailment`), f.namedNode(`${ns4}label`), f.literal('entailment', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}entailment`), f.namedNode(`${ns4}range`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}equals`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}equals`), f.namedNode(`${ns4}comment`), f.literal('Specifies a property that must have the same values as the value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}equals`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}equals`), f.namedNode(`${ns4}label`), f.literal('equals', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}equals`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}exists`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}expression`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}expression`), f.namedNode(`${ns4}comment`), f.literal('The node expression that must return true for the value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}expression`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}expression`), f.namedNode(`${ns4}label`), f.literal('expression', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}filterShape`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}filterShape`), f.namedNode(`${ns4}comment`), f.literal('The shape that all input nodes of the expression need to conform to.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}filterShape`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}filterShape`), f.namedNode(`${ns4}label`), f.literal('filter shape', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}filterShape`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}flags`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}flags`), f.namedNode(`${ns4}comment`), f.literal('An optional flag to be used with regular expression pattern matching.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}flags`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}flags`), f.namedNode(`${ns4}label`), f.literal('flags', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}flags`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}focusNode`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}focusNode`), f.namedNode(`${ns4}comment`), f.literal('The focus node that was validated when the result was produced.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}focusNode`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}AbstractResult`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}focusNode`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}focusNode`), f.namedNode(`${ns4}label`), f.literal('focus node', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}group`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}group`), f.namedNode(`${ns4}comment`), f.literal('Can be used to link to a property group to indicate that a property shape belongs to a group of related property shapes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}group`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}PropertyShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}group`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}group`), f.namedNode(`${ns4}label`), f.literal('group', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}group`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}PropertyGroup`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}groupConcat`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}hasValue`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}hasValue`), f.namedNode(`${ns4}comment`), f.literal('Specifies a value that must be among the value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}hasValue`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}hasValue`), f.namedNode(`${ns4}label`), f.literal('has value', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}if`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ignoredProperties`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ignoredProperties`), f.namedNode(`${ns4}comment`), f.literal('An optional RDF list of properties that are also permitted in addition to those explicitly enumerated via sh:property/sh:path.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ignoredProperties`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ignoredProperties`), f.namedNode(`${ns4}label`), f.literal('ignored properties', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}ignoredProperties`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}List`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}in`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}in`), f.namedNode(`${ns4}comment`), f.literal('Specifies a list of allowed values so that each value node must be among the members of the given list.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}in`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}in`), f.namedNode(`${ns4}label`), f.literal('in', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}in`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}List`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}intersection`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}intersection`), f.namedNode(`${ns4}comment`), f.literal('A list of node expressions that shall be intersected.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}intersection`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}intersection`), f.namedNode(`${ns4}label`), f.literal('intersection', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}inversePath`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}inversePath`), f.namedNode(`${ns4}comment`), f.literal('The (single) value of this property represents an inverse path (object to subject).', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}inversePath`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}inversePath`), f.namedNode(`${ns4}label`), f.literal('inverse path', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}inversePath`), f.namedNode(`${ns4}range`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}js`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}js`), f.namedNode(`${ns4}comment`), f.literal('Constraints expressed in JavaScript.'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}js`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}js`), f.namedNode(`${ns4}label`), f.literal('JavaScript constraint', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}js`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}JSConstraint`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsFunctionName`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsFunctionName`), f.namedNode(`${ns4}comment`), f.literal('The name of the JavaScript function to execute.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsFunctionName`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}JSExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsFunctionName`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsFunctionName`), f.namedNode(`${ns4}label`), f.literal('JavaScript function name', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsFunctionName`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsLibrary`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsLibrary`), f.namedNode(`${ns4}comment`), f.literal('Declares which JavaScript libraries are needed to execute this.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsLibrary`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsLibrary`), f.namedNode(`${ns4}label`), f.literal('JavaScript library', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsLibrary`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}JSLibrary`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsLibraryURL`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsLibraryURL`), f.namedNode(`${ns4}comment`), f.literal('Declares the URLs of a JavaScript library. This should be the absolute URL of a JavaScript file. Implementations may redirect those to local files.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsLibraryURL`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}JSLibrary`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsLibraryURL`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsLibraryURL`), f.namedNode(`${ns4}label`), f.literal('JavaScript library URL', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}jsLibraryURL`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}anyURI`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}labelTemplate`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}labelTemplate`), f.namedNode(`${ns4}comment`), f.literal('Outlines how human-readable labels of instances of the associated Parameterizable shall be produced. The values can contain {?paramName} as placeholders for the actual values of the given parameter.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}labelTemplate`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Parameterizable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}labelTemplate`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}labelTemplate`), f.namedNode(`${ns4}label`), f.literal('label template', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}languageIn`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}languageIn`), f.namedNode(`${ns4}comment`), f.literal('Specifies a list of language tags that all value nodes must have.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}languageIn`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}languageIn`), f.namedNode(`${ns4}label`), f.literal('language in', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}languageIn`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}List`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}lessThan`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}lessThan`), f.namedNode(`${ns4}comment`), f.literal('Specifies a property that must have smaller values than the value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}lessThan`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}lessThan`), f.namedNode(`${ns4}label`), f.literal('less than', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}lessThan`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}lessThanOrEquals`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}lessThanOrEquals`), f.namedNode(`${ns4}comment`), f.literal('Specifies a property that must have smaller or equal values than the value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}lessThanOrEquals`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}lessThanOrEquals`), f.namedNode(`${ns4}label`), f.literal('less than or equals', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}lessThanOrEquals`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}limit`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}max`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxCount`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxCount`), f.namedNode(`${ns4}comment`), f.literal('Specifies the maximum number of values in the set of value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxCount`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxCount`), f.namedNode(`${ns4}label`), f.literal('max count', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxCount`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxExclusive`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxExclusive`), f.namedNode(`${ns4}comment`), f.literal('Specifies the maximum exclusive value of each value node.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxExclusive`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxExclusive`), f.namedNode(`${ns4}label`), f.literal('max exclusive', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxInclusive`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxInclusive`), f.namedNode(`${ns4}comment`), f.literal('Specifies the maximum inclusive value of each value node.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxInclusive`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxInclusive`), f.namedNode(`${ns4}label`), f.literal('max inclusive', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxLength`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxLength`), f.namedNode(`${ns4}comment`), f.literal('Specifies the maximum string length of each value node.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxLength`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxLength`), f.namedNode(`${ns4}label`), f.literal('max length', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}maxLength`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}message`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}message`), f.namedNode(`${ns4}comment`), f.literal('A human-readable message (possibly with placeholders for variables) explaining the cause of the result.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}message`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}message`), f.namedNode(`${ns4}label`), f.literal('message', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}min`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minCount`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minCount`), f.namedNode(`${ns4}comment`), f.literal('Specifies the minimum number of values in the set of value nodes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minCount`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minCount`), f.namedNode(`${ns4}label`), f.literal('min count', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minCount`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minExclusive`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minExclusive`), f.namedNode(`${ns4}comment`), f.literal('Specifies the minimum exclusive value of each value node.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minExclusive`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minExclusive`), f.namedNode(`${ns4}label`), f.literal('min exclusive', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minInclusive`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minInclusive`), f.namedNode(`${ns4}comment`), f.literal('Specifies the minimum inclusive value of each value node.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minInclusive`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minInclusive`), f.namedNode(`${ns4}label`), f.literal('min inclusive', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minLength`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minLength`), f.namedNode(`${ns4}comment`), f.literal('Specifies the minimum string length of each value node.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minLength`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minLength`), f.namedNode(`${ns4}label`), f.literal('min length', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minLength`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}minus`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}name`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}name`), f.namedNode(`${ns4}comment`), f.literal('Human-readable labels for the property in the context of the surrounding shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}name`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}PropertyShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}name`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}name`), f.namedNode(`${ns4}label`), f.literal('name', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}namespace`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}namespace`), f.namedNode(`${ns4}comment`), f.literal('The namespace associated with a prefix in a prefix declaration.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}namespace`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}PrefixDeclaration`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}namespace`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}namespace`), f.namedNode(`${ns4}label`), f.literal('namespace', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}namespace`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}anyURI`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}node`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}node`), f.namedNode(`${ns4}comment`), f.literal('Specifies the node shape that all value nodes must conform to.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}node`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}node`), f.namedNode(`${ns4}label`), f.literal('node', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}node`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}NodeShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns4}comment`), f.literal('Specifies the node kind (e.g. IRI or literal) each value node.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns4}label`), f.literal('node kind', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}NodeKind`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodeValidator`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodeValidator`), f.namedNode(`${ns4}comment`), f.literal('The validator(s) used to evaluate a constraint in the context of a node shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodeValidator`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodeValidator`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodeValidator`), f.namedNode(`${ns4}label`), f.literal('shape validator', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodeValidator`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Validator`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodes`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodes`), f.namedNode(`${ns4}comment`), f.literal('The node expression producing the input nodes of a filter shape expression.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodes`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}nodes`), f.namedNode(`${ns4}label`), f.literal('nodes', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}not`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}not`), f.namedNode(`${ns4}comment`), f.literal('Specifies a shape that the value nodes must not conform to.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}not`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}not`), f.namedNode(`${ns4}label`), f.literal('not', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}not`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}object`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}object`), f.namedNode(`${ns4}comment`), f.literal('An expression producing the nodes that shall be inferred as objects.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}object`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}TripleRule`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}object`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}object`), f.namedNode(`${ns4}label`), f.literal('object', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}offset`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}oneOrMorePath`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}oneOrMorePath`), f.namedNode(`${ns4}comment`), f.literal('The (single) value of this property represents a path that is matched one or more times.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}oneOrMorePath`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}oneOrMorePath`), f.namedNode(`${ns4}label`), f.literal('one or more path', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}oneOrMorePath`), f.namedNode(`${ns4}range`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}optional`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}optional`), f.namedNode(`${ns4}comment`), f.literal('Indicates whether a parameter is optional.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}optional`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}optional`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}optional`), f.namedNode(`${ns4}label`), f.literal('optional', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}optional`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}boolean`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}or`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}or`), f.namedNode(`${ns4}comment`), f.literal('Specifies a list of shapes so that the value nodes must conform to at least one of the shapes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}or`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}or`), f.namedNode(`${ns4}label`), f.literal('or', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}or`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}List`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}order`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}order`), f.namedNode(`${ns4}comment`), f.literal('Specifies the relative order of this compared to its siblings. For example use 0 for the first, 1 for the second.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}order`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}order`), f.namedNode(`${ns4}label`), f.literal('order', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}orderBy`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}parameter`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}parameter`), f.namedNode(`${ns4}comment`), f.literal('The parameters of a function or constraint component.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}parameter`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Parameterizable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}parameter`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}parameter`), f.namedNode(`${ns4}label`), f.literal('parameter', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}parameter`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Parameter`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}path`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}path`), f.namedNode(`${ns4}comment`), f.literal('Specifies the property path of a property shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}path`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}PropertyShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}path`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}path`), f.namedNode(`${ns4}label`), f.literal('path', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}path`), f.namedNode(`${ns4}range`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}pattern`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}pattern`), f.namedNode(`${ns4}comment`), f.literal('Specifies a regular expression pattern that the string representations of the value nodes must match.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}pattern`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}pattern`), f.namedNode(`${ns4}label`), f.literal('pattern', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}pattern`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}predicate`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}predicate`), f.namedNode(`${ns4}comment`), f.literal('An expression producing the properties that shall be inferred as predicates.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}predicate`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}TripleRule`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}predicate`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}predicate`), f.namedNode(`${ns4}label`), f.literal('predicate', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}prefix`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}prefix`), f.namedNode(`${ns4}comment`), f.literal('The prefix of a prefix declaration.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}prefix`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}PrefixDeclaration`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}prefix`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}prefix`), f.namedNode(`${ns4}label`), f.literal('prefix', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}prefix`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}prefixes`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}prefixes`), f.namedNode(`${ns4}comment`), f.literal('The prefixes that shall be applied before parsing the associated SPARQL query.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}prefixes`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}SPARQLExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}prefixes`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}prefixes`), f.namedNode(`${ns4}label`), f.literal('prefixes', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}prefixes`), f.namedNode(`${ns4}range`), f.namedNode(`${ns3}Ontology`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}property`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}property`), f.namedNode(`${ns4}comment`), f.literal('Links a shape to its property shapes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}property`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}property`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}property`), f.namedNode(`${ns4}label`), f.literal('property', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}property`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}PropertyShape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}propertyValidator`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}propertyValidator`), f.namedNode(`${ns4}comment`), f.literal('The validator(s) used to evaluate a constraint in the context of a property shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}propertyValidator`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}propertyValidator`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}propertyValidator`), f.namedNode(`${ns4}label`), f.literal('property validator', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}propertyValidator`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Validator`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedMaxCount`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedMaxCount`), f.namedNode(`${ns4}comment`), f.literal('The maximum number of value nodes that can conform to the shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedMaxCount`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedMaxCount`), f.namedNode(`${ns4}label`), f.literal('qualified max count', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedMaxCount`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedMinCount`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedMinCount`), f.namedNode(`${ns4}comment`), f.literal('The minimum number of value nodes that must conform to the shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedMinCount`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedMinCount`), f.namedNode(`${ns4}label`), f.literal('qualified min count', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedMinCount`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedValueShape`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedValueShape`), f.namedNode(`${ns4}comment`), f.literal('The shape that a specified number of values must conform to.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedValueShape`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedValueShape`), f.namedNode(`${ns4}label`), f.literal('qualified value shape', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedValueShape`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedValueShapesDisjoint`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedValueShapesDisjoint`), f.namedNode(`${ns4}comment`), f.literal('Can be used to mark the qualified value shape to be disjoint with its sibling shapes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedValueShapesDisjoint`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedValueShapesDisjoint`), f.namedNode(`${ns4}label`), f.literal('qualified value shapes disjoint', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}qualifiedValueShapesDisjoint`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}boolean`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}result`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}result`), f.namedNode(`${ns4}comment`), f.literal('The validation results contained in a validation report.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}result`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}ValidationReport`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}result`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}result`), f.namedNode(`${ns4}label`), f.literal('result', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}result`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}ValidationResult`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultAnnotation`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultAnnotation`), f.namedNode(`${ns4}comment`), f.literal('Links a SPARQL validator with zero or more sh:ResultAnnotation instances, defining how to derive additional result properties based on the variables of the SELECT query.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultAnnotation`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}SPARQLSelectValidator`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultAnnotation`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultAnnotation`), f.namedNode(`${ns4}label`), f.literal('result annotation', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultAnnotation`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}ResultAnnotation`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultMessage`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultMessage`), f.namedNode(`${ns4}comment`), f.literal('Human-readable messages explaining the cause of the result.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultMessage`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}AbstractResult`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultMessage`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultMessage`), f.namedNode(`${ns4}label`), f.literal('result message', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultPath`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultPath`), f.namedNode(`${ns4}comment`), f.literal('The path of a validation result, based on the path of the validated property shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultPath`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}AbstractResult`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultPath`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultPath`), f.namedNode(`${ns4}label`), f.literal('result path', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultPath`), f.namedNode(`${ns4}range`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultSeverity`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultSeverity`), f.namedNode(`${ns4}comment`), f.literal('The severity of the result, e.g. warning.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultSeverity`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}AbstractResult`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultSeverity`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultSeverity`), f.namedNode(`${ns4}label`), f.literal('result severity', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}resultSeverity`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Severity`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}returnType`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}returnType`), f.namedNode(`${ns4}comment`), f.literal('The expected type of values returned by the associated function.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}returnType`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Function`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}returnType`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}returnType`), f.namedNode(`${ns4}label`), f.literal('return type', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}returnType`), f.namedNode(`${ns4}range`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}rule`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}rule`), f.namedNode(`${ns4}comment`), f.literal('The rules linked to a shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}rule`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}rule`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}rule`), f.namedNode(`${ns4}label`), f.literal('rule', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}rule`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Rule`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}select`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}select`), f.namedNode(`${ns4}comment`), f.literal('The SPARQL SELECT query to execute.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}select`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}SPARQLSelectExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}select`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}select`), f.namedNode(`${ns4}label`), f.literal('select', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}select`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}separator`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}severity`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}severity`), f.namedNode(`${ns4}comment`), f.literal('Defines the severity that validation results produced by a shape must have. Defaults to sh:Violation.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}severity`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}severity`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}severity`), f.namedNode(`${ns4}label`), f.literal('severity', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}severity`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Severity`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}shapesGraph`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}shapesGraph`), f.namedNode(`${ns4}comment`), f.literal('Shapes graphs that should be used when validating this data graph.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}shapesGraph`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns3}Ontology`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}shapesGraph`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}shapesGraph`), f.namedNode(`${ns4}label`), f.literal('shapes graph', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}shapesGraph`), f.namedNode(`${ns4}range`), f.namedNode(`${ns3}Ontology`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}shapesGraphWellFormed`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}shapesGraphWellFormed`), f.namedNode(`${ns4}comment`), f.literal('If true then the validation engine was certain that the shapes graph has passed all SHACL syntax requirements during the validation process.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}shapesGraphWellFormed`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}ValidationReport`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}shapesGraphWellFormed`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}shapesGraphWellFormed`), f.namedNode(`${ns4}label`), f.literal('shapes graph well-formed', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}shapesGraphWellFormed`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}boolean`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceConstraint`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceConstraint`), f.namedNode(`${ns4}comment`), f.literal('The constraint that was validated when the result was produced.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceConstraint`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}AbstractResult`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceConstraint`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceConstraint`), f.namedNode(`${ns4}label`), f.literal('source constraint', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceConstraintComponent`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceConstraintComponent`), f.namedNode(`${ns4}comment`), f.literal('The constraint component that is the source of the result.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceConstraintComponent`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}AbstractResult`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceConstraintComponent`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceConstraintComponent`), f.namedNode(`${ns4}label`), f.literal('source constraint component', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceConstraintComponent`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceShape`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceShape`), f.namedNode(`${ns4}comment`), f.literal('The shape that is was validated when the result was produced.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceShape`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}AbstractResult`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceShape`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceShape`), f.namedNode(`${ns4}label`), f.literal('source shape', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sourceShape`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sparql`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sparql`), f.namedNode(`${ns4}comment`), f.literal('Links a shape with SPARQL constraints.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sparql`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sparql`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sparql`), f.namedNode(`${ns4}label`), f.literal('constraint (in SPARQL)', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sparql`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}SPARQLConstraint`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}subject`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}subject`), f.namedNode(`${ns4}comment`), f.literal('An expression producing the resources that shall be inferred as subjects.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}subject`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}TripleRule`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}subject`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}subject`), f.namedNode(`${ns4}label`), f.literal('subject', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}suggestedShapesGraph`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}suggestedShapesGraph`), f.namedNode(`${ns4}comment`), f.literal('Suggested shapes graphs for this ontology. The values of this property may be used in the absence of specific sh:shapesGraph statements.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}suggestedShapesGraph`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns3}Ontology`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}suggestedShapesGraph`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}suggestedShapesGraph`), f.namedNode(`${ns4}label`), f.literal('suggested shapes graph', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}suggestedShapesGraph`), f.namedNode(`${ns4}range`), f.namedNode(`${ns3}Ontology`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}sum`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}target`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}target`), f.namedNode(`${ns4}comment`), f.literal('Links a shape to a target specified by an extension language, for example instances of sh:SPARQLTarget.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}target`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}target`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}target`), f.namedNode(`${ns4}label`), f.literal('target', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}target`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Target`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetClass`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetClass`), f.namedNode(`${ns4}comment`), f.literal('Links a shape to a class, indicating that all instances of the class must conform to the shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetClass`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetClass`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetClass`), f.namedNode(`${ns4}label`), f.literal('target class', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetClass`), f.namedNode(`${ns4}range`), f.namedNode(`${ns4}Class`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetNode`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetNode`), f.namedNode(`${ns4}comment`), f.literal('Links a shape to individual nodes, indicating that these nodes must conform to the shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetNode`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetNode`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetNode`), f.namedNode(`${ns4}label`), f.literal('target node', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetObjectsOf`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetObjectsOf`), f.namedNode(`${ns4}comment`), f.literal('Links a shape to a property, indicating that all all objects of triples that have the given property as their predicate must conform to the shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetObjectsOf`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetObjectsOf`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetObjectsOf`), f.namedNode(`${ns4}label`), f.literal('target objects of', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetObjectsOf`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns4}comment`), f.literal('Links a shape to a property, indicating that all subjects of triples that have the given property as their predicate must conform to the shape.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}Shape`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns4}label`), f.literal('target subjects of', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}targetSubjectsOf`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}then`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}this`), f.namedNode(`${ns2}type`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}this`), f.namedNode(`${ns4}comment`), f.literal('A node expression that represents the current focus node.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}this`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}this`), f.namedNode(`${ns4}label`), f.literal('this', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}union`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}union`), f.namedNode(`${ns4}comment`), f.literal('A list of node expressions that shall be used together.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}union`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}union`), f.namedNode(`${ns4}label`), f.literal('union', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}uniqueLang`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}uniqueLang`), f.namedNode(`${ns4}comment`), f.literal('Specifies whether all node values must have a unique (or no) language tag.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}uniqueLang`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}uniqueLang`), f.namedNode(`${ns4}label`), f.literal('unique languages', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}uniqueLang`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}boolean`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}update`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}update`), f.namedNode(`${ns4}comment`), f.literal('The SPARQL UPDATE to execute.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}update`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}SPARQLUpdateExecutable`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}update`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}update`), f.namedNode(`${ns4}label`), f.literal('update', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}update`), f.namedNode(`${ns4}range`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}validator`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}validator`), f.namedNode(`${ns4}comment`), f.literal('The validator(s) used to evaluate constraints of either node or property shapes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}validator`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}ConstraintComponent`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}validator`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}validator`), f.namedNode(`${ns4}label`), f.literal('validator', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}validator`), f.namedNode(`${ns4}range`), f.namedNode(`${ns1}Validator`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}value`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}value`), f.namedNode(`${ns4}comment`), f.literal('An RDF node that has caused the result.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}value`), f.namedNode(`${ns4}domain`), f.namedNode(`${ns1}AbstractResult`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}value`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}value`), f.namedNode(`${ns4}label`), f.literal('value', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}values`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}xone`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}xone`), f.namedNode(`${ns4}comment`), f.literal('Specifies a list of shapes so that the value nodes must conform to exactly one of the shapes.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}xone`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}xone`), f.namedNode(`${ns4}label`), f.literal('exactly one', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}xone`), f.namedNode(`${ns4}range`), f.namedNode(`${ns2}List`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}zeroOrMorePath`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}zeroOrMorePath`), f.namedNode(`${ns4}comment`), f.literal('The (single) value of this property represents a path that is matched zero or more times.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}zeroOrMorePath`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}zeroOrMorePath`), f.namedNode(`${ns4}label`), f.literal('zero or more path', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}zeroOrMorePath`), f.namedNode(`${ns4}range`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}zeroOrOnePath`), f.namedNode(`${ns2}type`), f.namedNode(`${ns2}Property`), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}zeroOrOnePath`), f.namedNode(`${ns4}comment`), f.literal('The (single) value of this property represents a path that is matched zero or one times.', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}zeroOrOnePath`), f.namedNode(`${ns4}isDefinedBy`), f.namedNode(ns1), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}zeroOrOnePath`), f.namedNode(`${ns4}label`), f.literal('zero or one path', 'en'), f.namedNode(ns1)),
        f.quad(f.namedNode(`${ns1}zeroOrOnePath`), f.namedNode(`${ns4}range`), f.namedNode(`${ns4}Resource`), f.namedNode(ns1)),
        f.quad(blankNodes[4], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[4], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[4], f.namedNode(`${ns1}node`), f.namedNode(`${ns5}ShapeShape`), f.namedNode(ns1)),
        f.quad(blankNodes[4], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}filterShape`), f.namedNode(ns1)),
        f.quad(blankNodes[40], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}IfExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[40], f.namedNode(`${ns2}rest`), blankNodes[41], f.namedNode(ns1)),
        f.quad(blankNodes[16], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[16], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[16], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[16], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}nodes`), f.namedNode(ns1)),
        f.quad(blankNodes[32], f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(blankNodes[32], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[32], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[32], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}select`), f.namedNode(ns1)),
        f.quad(blankNodes[6], f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(blankNodes[6], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[6], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}separator`), f.namedNode(ns1)),
        f.quad(blankNodes[42], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}BlankNodeOrLiteral`), f.namedNode(ns1)),
        f.quad(blankNodes[42], f.namedNode(`${ns2}rest`), blankNodes[43], f.namedNode(ns1)),
        f.quad(blankNodes[19], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(blankNodes[19], f.namedNode(`${ns2}rest`), blankNodes[44], f.namedNode(ns1)),
        f.quad(blankNodes[45], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}MinExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[45], f.namedNode(`${ns2}rest`), blankNodes[46], f.namedNode(ns1)),
        f.quad(blankNodes[47], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}SPARQLAskExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[47], f.namedNode(`${ns2}rest`), blankNodes[48], f.namedNode(ns1)),
        f.quad(blankNodes[25], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[25], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[25], f.namedNode(`${ns1}node`), f.namedNode(`${ns5}PathShape`), f.namedNode(ns1)),
        f.quad(blankNodes[25], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}path`), f.namedNode(ns1)),
        f.quad(blankNodes[49], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}MinusExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[49], f.namedNode(`${ns2}rest`), blankNodes[50], f.namedNode(ns1)),
        f.quad(blankNodes[46], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}MaxExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[46], f.namedNode(`${ns2}rest`), blankNodes[51], f.namedNode(ns1)),
        f.quad(blankNodes[52], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}LimitExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[52], f.namedNode(`${ns2}rest`), blankNodes[53], f.namedNode(ns1)),
        f.quad(blankNodes[8], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[8], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[8], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}then`), f.namedNode(ns1)),
        f.quad(blankNodes[44], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}IRI`), f.namedNode(ns1)),
        f.quad(blankNodes[44], f.namedNode(`${ns2}rest`), blankNodes[54], f.namedNode(ns1)),
        f.quad(blankNodes[55], f.namedNode(`${ns1}zeroOrMorePath`), f.namedNode(`${ns2}rest`), f.namedNode(ns1)),
        f.quad(blankNodes[5], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[5], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[5], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}nodes`), f.namedNode(ns1)),
        f.quad(blankNodes[56], f.namedNode(`${ns2}first`), blankNodes[57], f.namedNode(ns1)),
        f.quad(blankNodes[56], f.namedNode(`${ns2}rest`), f.namedNode(`${ns2}nil`), f.namedNode(ns1)),
        f.quad(blankNodes[0], f.namedNode(`${ns1}namespace`), f.literal('http://www.w3.org/ns/shacl#'), f.namedNode(ns1)),
        f.quad(blankNodes[0], f.namedNode(`${ns1}prefix`), f.literal('sh'), f.namedNode(ns1)),
        f.quad(blankNodes[58], f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNode`), f.namedNode(ns1)),
        f.quad(blankNodes[58], f.namedNode(`${ns1}not`), blankNodes[59], f.namedNode(ns1)),
        f.quad(blankNodes[18], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}FocusNodeOrConstantTermExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[18], f.namedNode(`${ns2}rest`), blankNodes[60], f.namedNode(ns1)),
        f.quad(blankNodes[15], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[15], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[15], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[15], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}min`), f.namedNode(ns1)),
        f.quad(blankNodes[30], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[30], f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNodeOrIRI`), f.namedNode(ns1)),
        f.quad(blankNodes[30], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}prefixes`), f.namedNode(ns1)),
        f.quad(blankNodes[61], f.namedNode(`${ns2}first`), blankNodes[55], f.namedNode(ns1)),
        f.quad(blankNodes[61], f.namedNode(`${ns2}rest`), blankNodes[62], f.namedNode(ns1)),
        f.quad(blankNodes[1], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[1], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[1], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[1], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}count`), f.namedNode(ns1)),
        f.quad(blankNodes[12], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[12], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[12], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[12], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}nodes`), f.namedNode(ns1)),
        f.quad(blankNodes[33], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[33], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[33], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}nodes`), f.namedNode(ns1)),
        f.quad(blankNodes[63], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[63], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[63], f.namedNode(`${ns1}node`), f.namedNode(`${ns7}ListShape`), f.namedNode(ns1)),
        f.quad(blankNodes[63], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}intersection`), f.namedNode(ns1)),
        f.quad(blankNodes[63], f.namedNode(`${ns1}property`), blankNodes[64], f.namedNode(ns1)),
        f.quad(blankNodes[13], f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(blankNodes[13], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[13], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[13], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}limit`), f.namedNode(ns1)),
        f.quad(blankNodes[59], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}ExistsExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[59], f.namedNode(`${ns2}rest`), blankNodes[40], f.namedNode(ns1)),
        f.quad(blankNodes[36], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[36], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[36], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[36], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}object`), f.namedNode(ns1)),
        f.quad(blankNodes[2], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[2], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[2], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[2], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}distinct`), f.namedNode(ns1)),
        f.quad(blankNodes[65], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}IntersectionExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[65], f.namedNode(`${ns2}rest`), blankNodes[66], f.namedNode(ns1)),
        f.quad(blankNodes[57], f.namedNode(`${ns1}xone`), blankNodes[59], f.namedNode(ns1)),
        f.quad(blankNodes[34], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[34], f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNodeOrIRI`), f.namedNode(ns1)),
        f.quad(blankNodes[34], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}prefixes`), f.namedNode(ns1)),
        f.quad(blankNodes[67], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}GroupConcatExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[67], f.namedNode(`${ns2}rest`), blankNodes[68], f.namedNode(ns1)),
        f.quad(blankNodes[20], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[20], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[20], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[20], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}nodes`), f.namedNode(ns1)),
        f.quad(blankNodes[69], f.namedNode(`${ns1}property`), blankNodes[63], f.namedNode(ns1)),
        f.quad(blankNodes[27], f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(blankNodes[27], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[27], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[27], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}ask`), f.namedNode(ns1)),
        f.quad(blankNodes[28], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[28], f.namedNode(`${ns1}nodeKind`), f.namedNode(`${ns1}BlankNodeOrIRI`), f.namedNode(ns1)),
        f.quad(blankNodes[28], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}prefixes`), f.namedNode(ns1)),
        f.quad(blankNodes[64], f.namedNode(`${ns1}minCount`), f.literal('2', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[64], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[64], f.namedNode(`${ns1}path`), blankNodes[61], f.namedNode(ns1)),
        f.quad(blankNodes[22], f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}boolean`), f.namedNode(ns1)),
        f.quad(blankNodes[22], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[22], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}desc`), f.namedNode(ns1)),
        f.quad(blankNodes[29], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[29], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[29], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}nodes`), f.namedNode(ns1)),
        f.quad(blankNodes[41], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}FilterShapeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[41], f.namedNode(`${ns2}rest`), blankNodes[70], f.namedNode(ns1)),
        f.quad(blankNodes[62], f.namedNode(`${ns2}first`), f.namedNode(`${ns2}first`), f.namedNode(ns1)),
        f.quad(blankNodes[62], f.namedNode(`${ns2}rest`), f.namedNode(`${ns2}nil`), f.namedNode(ns1)),
        f.quad(blankNodes[48], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}SPARQLSelectExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[48], f.namedNode(`${ns2}rest`), f.namedNode(`${ns2}nil`), f.namedNode(ns1)),
        f.quad(blankNodes[26], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[26], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[26], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}nodes`), f.namedNode(ns1)),
        f.quad(blankNodes[71], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}CountExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[71], f.namedNode(`${ns2}rest`), blankNodes[45], f.namedNode(ns1)),
        f.quad(blankNodes[7], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[7], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[7], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[7], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}groupConcat`), f.namedNode(ns1)),
        f.quad(blankNodes[54], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}Literal`), f.namedNode(ns1)),
        f.quad(blankNodes[54], f.namedNode(`${ns2}rest`), blankNodes[72], f.namedNode(ns1)),
        f.quad(blankNodes[23], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[23], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[23], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[23], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}nodes`), f.namedNode(ns1)),
        f.quad(blankNodes[21], f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}integer`), f.namedNode(ns1)),
        f.quad(blankNodes[21], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[21], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[21], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}offset`), f.namedNode(ns1)),
        f.quad(blankNodes[50], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}DistinctExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[50], f.namedNode(`${ns2}rest`), blankNodes[71], f.namedNode(ns1)),
        f.quad(blankNodes[14], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[14], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[14], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[14], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}max`), f.namedNode(ns1)),
        f.quad(blankNodes[51], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}SumExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[51], f.namedNode(`${ns2}rest`), blankNodes[67], f.namedNode(ns1)),
        f.quad(blankNodes[68], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}OrderByExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[68], f.namedNode(`${ns2}rest`), blankNodes[52], f.namedNode(ns1)),
        f.quad(blankNodes[60], f.namedNode(`${ns2}first`), blankNodes[58], f.namedNode(ns1)),
        f.quad(blankNodes[60], f.namedNode(`${ns2}rest`), blankNodes[56], f.namedNode(ns1)),
        f.quad(blankNodes[24], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[24], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[24], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[24], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}orderBy`), f.namedNode(ns1)),
        f.quad(blankNodes[35], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[35], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[35], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[35], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}sum`), f.namedNode(ns1)),
        f.quad(blankNodes[3], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[3], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[3], f.namedNode(`${ns1}node`), f.namedNode(`${ns5}ShapeShape`), f.namedNode(ns1)),
        f.quad(blankNodes[3], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}exists`), f.namedNode(ns1)),
        f.quad(blankNodes[37], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[37], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[37], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[37], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}subject`), f.namedNode(ns1)),
        f.quad(blankNodes[11], f.namedNode(`${ns1}and`), blankNodes[73], f.namedNode(ns1)),
        f.quad(blankNodes[11], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[11], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[11], f.namedNode(`${ns1}node`), f.namedNode(`${ns7}ListShape`), f.namedNode(ns1)),
        f.quad(blankNodes[11], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}intersection`), f.namedNode(ns1)),
        f.quad(blankNodes[9], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[9], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[9], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[9], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}if`), f.namedNode(ns1)),
        f.quad(blankNodes[53], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}OffsetExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[53], f.namedNode(`${ns2}rest`), blankNodes[47], f.namedNode(ns1)),
        f.quad(blankNodes[72], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}BlankNodeOrIRI`), f.namedNode(ns1)),
        f.quad(blankNodes[72], f.namedNode(`${ns2}rest`), blankNodes[42], f.namedNode(ns1)),
        f.quad(blankNodes[70], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}PathExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[70], f.namedNode(`${ns2}rest`), blankNodes[65], f.namedNode(ns1)),
        f.quad(blankNodes[38], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[38], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[38], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[38], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}predicate`), f.namedNode(ns1)),
        f.quad(blankNodes[39], f.namedNode(`${ns1}and`), blankNodes[74], f.namedNode(ns1)),
        f.quad(blankNodes[39], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[39], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[39], f.namedNode(`${ns1}node`), f.namedNode(`${ns7}ListShape`), f.namedNode(ns1)),
        f.quad(blankNodes[39], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}union`), f.namedNode(ns1)),
        f.quad(blankNodes[66], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}UnionExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[66], f.namedNode(`${ns2}rest`), blankNodes[49], f.namedNode(ns1)),
        f.quad(blankNodes[10], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[10], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[10], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}else`), f.namedNode(ns1)),
        f.quad(blankNodes[17], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[17], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[17], f.namedNode(`${ns1}node`), f.namedNode(`${ns1}NodeExpression`), f.namedNode(ns1)),
        f.quad(blankNodes[17], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}minus`), f.namedNode(ns1)),
        f.quad(blankNodes[74], f.namedNode(`${ns2}first`), blankNodes[75], f.namedNode(ns1)),
        f.quad(blankNodes[74], f.namedNode(`${ns2}rest`), f.namedNode(`${ns2}nil`), f.namedNode(ns1)),
        f.quad(blankNodes[73], f.namedNode(`${ns2}first`), blankNodes[75], f.namedNode(ns1)),
        f.quad(blankNodes[73], f.namedNode(`${ns2}rest`), f.namedNode(`${ns2}nil`), f.namedNode(ns1)),
        f.quad(blankNodes[31], f.namedNode(`${ns1}datatype`), f.namedNode(`${ns6}string`), f.namedNode(ns1)),
        f.quad(blankNodes[31], f.namedNode(`${ns1}maxCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[31], f.namedNode(`${ns1}minCount`), f.literal('1', f.namedNode(`${ns6}integer`)), f.namedNode(ns1)),
        f.quad(blankNodes[31], f.namedNode(`${ns1}path`), f.namedNode(`${ns1}construct`), f.namedNode(ns1)),
        f.quad(blankNodes[43], f.namedNode(`${ns2}first`), f.namedNode(`${ns1}IRIOrLiteral`), f.namedNode(ns1)),
        f.quad(blankNodes[43], f.namedNode(`${ns2}rest`), f.namedNode(`${ns2}nil`), f.namedNode(ns1))
    ];
};
