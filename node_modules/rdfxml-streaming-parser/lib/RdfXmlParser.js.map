{"version":3,"file":"RdfXmlParser.js","sourceRoot":"","sources":["RdfXmlParser.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RDF from \"@rdfjs/types\";\nimport {resolve} from \"relative-to-absolute-iri\";\nimport {SaxesParser, SaxesTagNS} from \"@rubensworks/saxes\";\nimport {PassThrough, Transform} from \"readable-stream\";\nimport {ParseError} from \"./ParseError\";\nimport {DataFactory} from \"rdf-data-factory\";\nimport {IriValidationStrategy, validateIri} from \"validate-iri\";\nimport EventEmitter = NodeJS.EventEmitter;\n\nexport class RdfXmlParser extends Transform implements RDF.Sink<EventEmitter, RDF.Stream> {\n  public static readonly MIME_TYPE = 'application/rdf+xml';\n\n  public static readonly RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\n  public static readonly XML = 'http://www.w3.org/XML/1998/namespace';\n  public static readonly ITS = 'http://www.w3.org/2005/11/its';\n  public static readonly FORBIDDEN_NODE_ELEMENTS = [\n    'RDF',\n    'ID',\n    'about',\n    'bagID',\n    'parseType',\n    'resource',\n    'nodeID',\n    'li',\n    'aboutEach',\n    'aboutEachPrefix',\n  ];\n  public static readonly FORBIDDEN_PROPERTY_ELEMENTS = [\n    'Description',\n    'RDF',\n    'ID',\n    'about',\n    'bagID',\n    'parseType',\n    'resource',\n    'nodeID',\n    'aboutEach',\n    'aboutEachPrefix',\n  ];\n  // tslint:disable-next-line:max-line-length\n  public static readonly NCNAME_MATCHER = /^([A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\u{F8}-\\u{2FF}\\u{370}-\\u{37D}\\u{37F}-\\u{1FFF}\\u{200C}-\\u{200D}\\u{2070}-\\u{218F}\\u{2C00}-\\u{2FEF}\\u{3001}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFFD}\\u{10000}-\\u{EFFFF}_])([A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\u{F8}-\\u{2FF}\\u{370}-\\u{37D}\\u{37F}-\\u{1FFF}\\u{200C}-\\u{200D}\\u{2070}-\\u{218F}\\u{2C00}-\\u{2FEF}\\u{3001}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFFD}\\u{10000}-\\u{EFFFF}_\\-.0-9#xB7\\u{0300}-\\u{036F}\\u{203F}-\\u{2040}])*$/u;\n\n  public readonly trackPosition?: boolean;\n\n  private readonly options: IRdfXmlParserArgs;\n  private readonly dataFactory: RDF.DataFactory;\n  private readonly baseIRI: string;\n  private readonly defaultGraph?: RDF.Quad_Graph;\n  private readonly allowDuplicateRdfIds?: boolean;\n  private readonly saxParser: SaxesParser;\n  private readonly validateUri: boolean;\n  private readonly iriValidationStrategy: IriValidationStrategy;\n\n  private readonly activeTagStack: IActiveTag[] = [];\n  private readonly nodeIds: {[id: string]: boolean} = {};\n\n  constructor(args?: IRdfXmlParserArgs) {\n    super({ readableObjectMode: true });\n\n    if (args) {\n      Object.assign(this, args);\n      this.options = args;\n    }\n    if (!this.dataFactory) {\n      this.dataFactory = new DataFactory();\n    }\n    if (!this.baseIRI) {\n      this.baseIRI = '';\n    }\n    if (!this.defaultGraph) {\n      this.defaultGraph = this.dataFactory.defaultGraph();\n    }\n    if (this.validateUri !== false) {\n      this.validateUri = true;\n    }\n    if (!this.iriValidationStrategy) {\n      this.iriValidationStrategy = this.validateUri ? IriValidationStrategy.Pragmatic : IriValidationStrategy.None;\n    }\n\n    this.saxParser = new SaxesParser({ xmlns: true, position: this.trackPosition });\n\n    this.attachSaxListeners();\n  }\n\n  /**\n   * Parses the given text stream into a quad stream.\n   * @param {NodeJS.EventEmitter} stream A text stream.\n   * @return {RDF.Stream} A quad stream.\n   */\n  public import(stream: EventEmitter): RDF.Stream {\n    const output = new PassThrough({ readableObjectMode: true });\n    stream.on('error', (error) => parsed.emit('error', error));\n    stream.on('data', (data) => output.push(data));\n    stream.on('end', () => output.push(null));\n    const parsed = output.pipe(new RdfXmlParser(this.options));\n    return parsed;\n  }\n\n  public _transform(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null, data?: any) => void) {\n    try {\n      this.saxParser.write(chunk);\n    } catch (e) {\n      return callback(e);\n    }\n    callback();\n  }\n\n  /**\n   * Create a new parse error instance.\n   * @param {string} message An error message.\n   * @return {Error} An error instance.\n   */\n  public newParseError(message: string): Error {\n    return new ParseError(this, message);\n  }\n\n  /**\n   * Convert the given value to a IRI by taking into account the baseIRI.\n   *\n   * This will follow the RDF/XML spec for converting values with baseIRIs to a IRI.\n   *\n   * @param {string} value The value to convert to an IRI.\n   * @param {IActiveTag} activeTag The active tag.\n   * @return {NamedNode} an IRI.\n   */\n  public valueToUri(value: string, activeTag: IActiveTag): RDF.NamedNode {\n    return this.uriToNamedNode(resolve(value, activeTag.baseIRI));\n  }\n\n  /**\n   * Convert the given value URI string to a named node.\n   *\n   * This throw an error if the URI is invalid.\n   *\n   * @param {string} uri A URI string.\n   * @return {NamedNode} a named node.\n   */\n  public uriToNamedNode(uri: string): RDF.NamedNode {\n    // Validate URI\n    const uriValidationResult = validateIri(uri, this.iriValidationStrategy);\n    if (uriValidationResult instanceof Error) {\n      throw this.newParseError(uriValidationResult.message);\n    }\n    return this.dataFactory.namedNode(uri);\n  }\n\n  /**\n   * Validate the given value as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName\n   * If it is invalid, an error will thrown emitted.\n   * @param {string} value A value.\n   */\n  public validateNcname(value: string) {\n    // Validate term as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName\n    if (!RdfXmlParser.NCNAME_MATCHER.test(value)) {\n      throw this.newParseError(`Not a valid NCName: ${value}`);\n    }\n  }\n\n  /**\n   * Create a new literal term.\n   * @param value The literal value.\n   * @param activeTag The active tag.\n   */\n  public createLiteral(value: string, activeTag: IActiveTag): RDF.Literal {\n    return this.dataFactory.literal(value, activeTag.datatype ? activeTag.datatype : activeTag.language ? { language: activeTag.language, direction: activeTag.rdfVersion ? activeTag.direction : undefined } : undefined)\n  }\n\n  protected attachSaxListeners() {\n    this.saxParser.on('error', (error) => this.emit('error', error));\n    this.saxParser.on('opentag', this.onTag.bind(this));\n    this.saxParser.on('text', this.onText.bind(this));\n    this.saxParser.on('cdata', this.onText.bind(this));\n    this.saxParser.on('closetag', this.onCloseTag.bind(this));\n    this.saxParser.on('doctype', this.onDoctype.bind(this));\n  }\n\n  /**\n   * Handle the given tag.\n   * @param {SaxesTagNS} tag A SAX tag.\n   */\n  protected onTag(tag: SaxesTagNS) {\n    // Get parent tag\n    const parentTag: IActiveTag = this.activeTagStack.length\n      ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n    let currentParseType = ParseType.RESOURCE;\n    if (parentTag) {\n      parentTag.hadChildren = true;\n      currentParseType = parentTag.childrenParseType;\n    }\n\n    // Check if this tag needs to be converted to a string\n    if (parentTag && parentTag.childrenStringTags) {\n      // Convert this tag to a string\n      const tagName: string = tag.name;\n      let attributes: string = '';\n      for (const { key, value } of parentTag.namespaces || []) {\n        attributes += ` ${key}=\"${value}\"`;\n      }\n      for (const attributeKey in tag.attributes) {\n        attributes += ` ${attributeKey}=\"${tag.attributes[attributeKey].value}\"`;\n      }\n      const tagContents: string = `${tagName}${attributes}`;\n      const tagString: string = `<${tagContents}>`;\n      parentTag.childrenStringTags.push(tagString);\n\n      // Inherit the array, so that deeper tags are appended to this same array\n      const stringActiveTag: IActiveTag = {childrenStringTags: parentTag.childrenStringTags};\n      stringActiveTag.childrenStringEmitClosingTag = `</${tagName}>`;\n      this.activeTagStack.push(stringActiveTag);\n\n      // Halt any further processing\n      return;\n    }\n\n    const activeTag: IActiveTag = {};\n    if (parentTag) {\n      // Inherit properties from parent\n      activeTag.language = parentTag.language;\n      activeTag.direction = parentTag.direction;\n      activeTag.baseIRI = parentTag.baseIRI;\n      activeTag.childrenTripleTerms = parentTag.childrenTripleTerms;\n      activeTag.rdfVersion = parentTag.rdfVersion;\n    } else {\n      activeTag.baseIRI = this.baseIRI;\n    }\n    this.activeTagStack.push(activeTag);\n\n    if (currentParseType === ParseType.RESOURCE) {\n      this.onTagResource(tag, activeTag, parentTag, !parentTag);\n    } else { // currentParseType === ParseType.PROPERTY\n      this.onTagProperty(tag, activeTag, parentTag);\n    }\n\n    for (const attributeKey in tag.attributes) {\n      const attribute = tag.attributes[attributeKey];\n      if (attribute.prefix === 'xmlns') {\n        if (!activeTag.namespaces) {\n          activeTag.namespaces = [];\n        }\n        activeTag.namespaces.push({ key: `${attribute.prefix}:${attribute.local}`, value: attribute.value });\n      }\n    }\n    if (parentTag && parentTag.namespaces) {\n      activeTag.namespaces = [ ...activeTag.namespaces || [], ...parentTag.namespaces ];\n    }\n  }\n\n  /**\n   * Handle the given node element in resource-mode.\n   * @param {SaxesTagNS} tag A SAX tag.\n   * @param {IActiveTag} activeTag The currently active tag.\n   * @param {IActiveTag} parentTag The parent tag or null.\n   * @param {boolean} rootTag If we are currently processing the root tag.\n   */\n  protected onTagResource(tag: SaxesTagNS, activeTag: IActiveTag, parentTag: IActiveTag, rootTag: boolean) {\n    activeTag.childrenParseType = ParseType.PROPERTY;\n    // Assume that the current node is a _typed_ node (2.13), unless we find an rdf:Description as node name\n    let typedNode: boolean = true;\n    if (tag.uri === RdfXmlParser.RDF) {\n      // Check forbidden property element names\n      if (!rootTag && RdfXmlParser.FORBIDDEN_NODE_ELEMENTS.indexOf(tag.local) >= 0) {\n        throw this.newParseError(`Illegal node element name: ${tag.local}`);\n      }\n\n      switch (tag.local) {\n      case 'RDF':\n        // Tags under <rdf:RDF> must always be resources\n        activeTag.childrenParseType = ParseType.RESOURCE;\n      case 'Description':\n        typedNode = false;\n      }\n    }\n\n    const predicates: RDF.NamedNode[] = [];\n    const objects: string[] = [];\n\n    // Collect all attributes as triples\n    // Assign subject value only after all attributes have been processed, because baseIRI may change the final val\n    let activeSubjectValue: string = null;\n    let claimSubjectNodeId: boolean = false;\n    let subjectValueBlank: boolean = false;\n    let explicitType: string = null;\n    for (const attributeKey in tag.attributes) {\n      const attribute = tag.attributes[attributeKey];\n      if (attribute.uri === RdfXmlParser.RDF && attribute.local === 'version') {\n        this.setVersion(activeTag, attribute.value);\n        continue;\n      } else if (parentTag && attribute.uri === RdfXmlParser.RDF) {\n        switch (attribute.local) {\n        case 'about':\n          if (activeSubjectValue) {\n            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n          }\n          activeSubjectValue = attribute.value;\n          continue;\n        case 'ID':\n          if (activeSubjectValue) {\n            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n          }\n          this.validateNcname(attribute.value);\n          activeSubjectValue = '#' + attribute.value;\n          claimSubjectNodeId = true;\n          continue;\n        case 'nodeID':\n          if (activeSubjectValue) {\n            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n          }\n          this.validateNcname(attribute.value);\n          activeSubjectValue = attribute.value;\n          subjectValueBlank = true;\n          continue;\n        case 'bagID':\n          throw this.newParseError(`rdf:bagID is not supported.`);\n        case 'type':\n          // Emit the rdf:type later as named node instead of the default literal\n          explicitType = attribute.value;\n          continue;\n        case 'aboutEach':\n          throw this.newParseError(`rdf:aboutEach is not supported.`);\n        case 'aboutEachPrefix':\n          throw this.newParseError(`rdf:aboutEachPrefix is not supported.`);\n        case 'li':\n          throw this.newParseError(`rdf:li on node elements are not supported.`);\n        }\n      } else if (attribute.uri === RdfXmlParser.XML) {\n        if (attribute.local === 'lang') {\n          activeTag.language = attribute.value === '' ? null : attribute.value.toLowerCase();\n          continue;\n        } else if (attribute.local === 'base') {\n          // SAX Parser does not expand xml:base, based on DOCTYPE, so we have to do it manually\n          activeTag.baseIRI = resolve(attribute.value, activeTag.baseIRI);\n          continue;\n        }\n      } else if (attribute.uri === RdfXmlParser.ITS && attribute.local === 'dir') {\n        this.setDirection(activeTag, attribute.value);\n        continue;\n      }\n\n      // Interpret attributes at this point as properties on this node,\n      // but we ignore attributes that have no prefix or known expanded URI\n      if (attribute.prefix !== 'xml' && attribute.prefix !== 'xmlns'\n          && (attribute.prefix !== '' || attribute.local !== 'xmlns')\n        && attribute.uri) {\n        predicates.push(this.uriToNamedNode(attribute.uri + attribute.local));\n        objects.push(attribute.value);\n      }\n    }\n\n    // Create the subject value _after_ all attributes have been processed\n    if (activeSubjectValue !== null) {\n      activeTag.subject = subjectValueBlank\n        ? this.dataFactory.blankNode(activeSubjectValue) : this.valueToUri(activeSubjectValue, activeTag);\n      if (claimSubjectNodeId) {\n        this.claimNodeId(activeTag.subject);\n      }\n    }\n\n    // Force the creation of a subject if it doesn't exist yet\n    if (!activeTag.subject) {\n      activeTag.subject = this.dataFactory.blankNode();\n    }\n\n    // Emit the type if we're at a typed node\n    if (typedNode) {\n      const type: RDF.NamedNode = this.uriToNamedNode(tag.uri + tag.local);\n      this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'),\n        type, parentTag ? parentTag.reifiedStatementId : null, activeTag.childrenTripleTerms, activeTag.reifier);\n    }\n\n    if (parentTag) {\n      // If the parent tag defined a predicate, add the current tag as property value\n      if (parentTag.predicate) {\n        if (parentTag.childrenCollectionSubject) {\n          // RDF:List-based properties\n          const linkTerm: RDF.BlankNode = this.dataFactory.blankNode();\n          const restTerm = this.dataFactory.namedNode(RdfXmlParser.RDF + 'rest');\n\n          // Emit <x> <p> <current-chain> OR <previous-chain> <rdf:rest> <current-chain>\n          const isRestTerm = parentTag.childrenCollectionPredicate.equals(restTerm);\n          this.emitTriple(parentTag.childrenCollectionSubject,\n            parentTag.childrenCollectionPredicate, linkTerm, isRestTerm ? null : parentTag.reifiedStatementId, parentTag.childrenTripleTerms, isRestTerm ? null : parentTag.reifier);\n\n          // Emit <current-chain> <rdf:first> value\n          this.emitTriple(linkTerm, this.dataFactory.namedNode(RdfXmlParser.RDF + 'first'),\n            activeTag.subject, null, activeTag.childrenTripleTerms);\n\n          // Store <current-chain> in the parent node\n          parentTag.childrenCollectionSubject = linkTerm;\n          parentTag.childrenCollectionPredicate = restTerm;\n        } else { // !parentTag.predicateEmitted\n          // Set-based properties\n          if (!parentTag.childrenTagsToTripleTerms) {\n            this.emitTriple(parentTag.subject, parentTag.predicate, activeTag.subject, parentTag.reifiedStatementId, parentTag.childrenTripleTerms, parentTag.reifier);\n            parentTag.predicateEmitted = true;\n          }\n\n          // Emit pending properties on the parent tag that had no defined subject yet.\n          for (let i = 0; i < parentTag.predicateSubPredicates.length; i++) {\n            this.emitTriple(activeTag.subject, parentTag.predicateSubPredicates[i],\n              parentTag.predicateSubObjects[i], null, parentTag.childrenTripleTerms, parentTag.reifier);\n          }\n\n          // Cleanup so we don't emit them again when the parent tag is closed\n          parentTag.predicateSubPredicates = [];\n          parentTag.predicateSubObjects = [];\n        }\n      }\n\n      // Emit all collected triples\n      for (let i = 0; i < predicates.length; i++) {\n        const object: RDF.Term = this.createLiteral(objects[i], activeTag);\n        this.emitTriple(activeTag.subject, predicates[i], object, parentTag.reifiedStatementId, parentTag.childrenTripleTerms, parentTag.reifier);\n      }\n      // Emit the rdf:type as named node instead of literal\n      if (explicitType) {\n        this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'),\n          this.uriToNamedNode(explicitType), null, activeTag.childrenTripleTerms, activeTag.reifier);\n      }\n    }\n  }\n\n  /**\n   * Handle the given property element in property-mode.\n   * @param {SaxesTagNS} tag A SAX tag.\n   * @param {IActiveTag} activeTag The currently active tag.\n   * @param {IActiveTag} parentTag The parent tag or null.\n   */\n  protected onTagProperty(tag: SaxesTagNS, activeTag: IActiveTag, parentTag: IActiveTag) {\n    activeTag.childrenParseType = ParseType.RESOURCE;\n    activeTag.subject = parentTag.subject; // Inherit parent subject\n    if (tag.uri === RdfXmlParser.RDF && tag.local === 'li') {\n      // Convert rdf:li to rdf:_x\n      if (!parentTag.listItemCounter) {\n        parentTag.listItemCounter = 1;\n      }\n      activeTag.predicate = this.uriToNamedNode(tag.uri + '_' + parentTag.listItemCounter++);\n    } else {\n      activeTag.predicate = this.uriToNamedNode(tag.uri + tag.local);\n    }\n\n    // Check forbidden property element names\n    if (tag.uri === RdfXmlParser.RDF\n      && RdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS.indexOf(tag.local) >= 0) {\n      throw this.newParseError(`Illegal property element name: ${tag.local}`);\n    }\n\n    activeTag.predicateSubPredicates = [];\n    activeTag.predicateSubObjects = [];\n    let parseType: boolean = false;\n    let attributedProperty: boolean = false;\n\n    // Collect all attributes as triples\n    // Assign subject value only after all attributes have been processed, because baseIRI may change the final val\n    let activeSubSubjectValue: string = null;\n    let subSubjectValueBlank = true;\n    const predicates: RDF.NamedNode[] = [];\n    const objects: (RDF.NamedNode | RDF.BlankNode | RDF.Literal)[] = [];\n    for (const propertyAttributeKey in tag.attributes) {\n      const propertyAttribute = tag.attributes[propertyAttributeKey];\n      if (propertyAttribute.uri === RdfXmlParser.RDF && propertyAttribute.local === 'version') {\n        this.setVersion(activeTag, propertyAttribute.value);\n        continue;\n      } else if (propertyAttribute.uri === RdfXmlParser.RDF) {\n        switch (propertyAttribute.local) {\n        case 'resource':\n          if (activeSubSubjectValue) {\n            throw this.newParseError(`Found both rdf:resource (${propertyAttribute.value\n              }) and rdf:nodeID (${activeSubSubjectValue}).`);\n          }\n          if (parseType) {\n            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:resource (${\n                propertyAttribute.value})`);\n          }\n          activeTag.hadChildren = true;\n          activeSubSubjectValue = propertyAttribute.value;\n          subSubjectValueBlank = false;\n          continue;\n        case 'datatype':\n          if (attributedProperty) {\n            throw this.newParseError(\n              `Found both non-rdf:* property attributes and rdf:datatype (${propertyAttribute.value}).`);\n          }\n          if (parseType) {\n            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${\n              propertyAttribute.value})`);\n          }\n          activeTag.datatype = this.valueToUri(propertyAttribute.value, activeTag);\n          continue;\n        case 'nodeID':\n          if (attributedProperty) {\n            throw this.newParseError(\n              `Found both non-rdf:* property attributes and rdf:nodeID (${propertyAttribute.value}).`);\n          }\n          if (activeTag.hadChildren) {\n            throw this.newParseError(`Found both rdf:resource and rdf:nodeID (${propertyAttribute.value}).`);\n          }\n          if (parseType) {\n            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID (${\n              propertyAttribute.value})`);\n          }\n          this.validateNcname(propertyAttribute.value);\n          activeTag.hadChildren = true;\n          activeSubSubjectValue = propertyAttribute.value;\n          subSubjectValueBlank = true;\n          continue;\n        case 'bagID':\n          throw this.newParseError(`rdf:bagID is not supported.`);\n        case 'parseType':\n          // Validation\n          if (attributedProperty) {\n            throw this.newParseError(`rdf:parseType is not allowed when non-rdf:* property attributes are present`);\n          }\n          if (activeTag.datatype) {\n            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${\n              activeTag.datatype.value})`);\n          }\n          if (activeSubSubjectValue) {\n            throw this.newParseError(\n              `rdf:parseType is not allowed on property elements with rdf:nodeID or rdf:resource (${\n                activeSubSubjectValue})`);\n          }\n\n          if (propertyAttribute.value === 'Resource') {\n            parseType = true;\n            activeTag.childrenParseType = ParseType.PROPERTY;\n\n            // Turn this property element into a node element\n            const nestedBNode: RDF.BlankNode = this.dataFactory.blankNode();\n            this.emitTriple(activeTag.subject, activeTag.predicate, nestedBNode, activeTag.reifiedStatementId, activeTag.childrenTripleTerms, activeTag.reifier);\n            activeTag.subject = nestedBNode;\n            activeTag.predicate = null;\n          } else if (propertyAttribute.value === 'Collection') {\n            parseType = true;\n            // Interpret children as being part of an rdf:List\n            activeTag.hadChildren = true;\n            activeTag.childrenCollectionSubject = activeTag.subject;\n            activeTag.childrenCollectionPredicate = activeTag.predicate;\n            subSubjectValueBlank = false;\n          } else if (propertyAttribute.value === 'Literal') {\n            parseType = true;\n            // Interpret children as being part of a literal string\n            activeTag.childrenTagsToString = true;\n            activeTag.childrenStringTags = [];\n          } else if (propertyAttribute.value === 'Triple') {\n            parseType = true;\n            // Collect children as triple terms\n            activeTag.childrenTagsToTripleTerms = true;\n            activeTag.childrenTripleTerms = [];\n          }\n          continue;\n        case 'ID':\n          this.validateNcname(propertyAttribute.value);\n          activeTag.reifiedStatementId = this.valueToUri('#' + propertyAttribute.value, activeTag);\n          this.claimNodeId(activeTag.reifiedStatementId);\n          continue;\n        case 'annotation':\n          activeTag.reifier = this.dataFactory.namedNode(propertyAttribute.value);\n          continue;\n        case 'annotationNodeID':\n          activeTag.reifier = this.dataFactory.blankNode(propertyAttribute.value);\n          continue;\n        }\n      } else if (propertyAttribute.uri === RdfXmlParser.XML && propertyAttribute.local === 'lang') {\n        activeTag.language = propertyAttribute.value === ''\n          ? null : propertyAttribute.value.toLowerCase();\n        continue;\n      } else if (propertyAttribute.uri === RdfXmlParser.ITS && propertyAttribute.local === 'dir') {\n        this.setDirection(activeTag, propertyAttribute.value);\n        continue;\n      } else if (propertyAttribute.uri === RdfXmlParser.ITS && propertyAttribute.local === 'version') {\n        // Ignore its:version\n        continue;\n      }\n\n      // Interpret attributes at this point as properties via implicit blank nodes on the property,\n      // but we ignore attributes that have no prefix or known expanded URI\n      if (propertyAttribute.prefix !== 'xml' && propertyAttribute.prefix !== 'xmlns'\n          && (propertyAttribute.prefix !== '' || propertyAttribute.local !== 'xmlns')\n        && propertyAttribute.uri) {\n        if (parseType || activeTag.datatype) {\n          throw this.newParseError(`Found illegal rdf:* properties on property element with attribute: ${\n            propertyAttribute.value}`);\n        }\n        activeTag.hadChildren = true;\n        attributedProperty = true;\n        predicates.push(this.uriToNamedNode(propertyAttribute.uri + propertyAttribute.local));\n        objects.push(this.createLiteral(propertyAttribute.value, activeTag));\n      }\n    }\n\n    // Create the subject value _after_ all attributes have been processed\n    if (activeSubSubjectValue !== null) {\n      const subjectParent: RDF.Term = activeTag.subject;\n      activeTag.subject = subSubjectValueBlank\n        ? this.dataFactory.blankNode(activeSubSubjectValue) : this.valueToUri(activeSubSubjectValue, activeTag);\n      this.emitTriple(subjectParent, activeTag.predicate, activeTag.subject, activeTag.reifiedStatementId, activeTag.childrenTripleTerms, activeTag.reifier);\n\n      // Emit our buffered triples\n      for (let i = 0; i < predicates.length; i++) {\n        this.emitTriple(activeTag.subject, predicates[i], objects[i], null, activeTag.childrenTripleTerms, activeTag.reifier);\n      }\n      activeTag.predicateEmitted = true;\n    } else if (subSubjectValueBlank) {\n      // The current property element has no defined subject\n      // Let's buffer the properties until the child node defines a subject,\n      // or if the tag closes.\n      activeTag.predicateSubPredicates = predicates;\n      activeTag.predicateSubObjects = objects;\n      activeTag.predicateEmitted = false;\n    }\n  }\n\n  /**\n   * Emit the given triple to the stream.\n   * @param {Term} subject A subject term.\n   * @param {Term} predicate A predicate term.\n   * @param {Term} object An object term.\n   * @param {Term} statementId An optional resource that identifies the triple.\n   *                           If truthy, then the given triple will also be emitted reified.\n   * @param childrenTripleTerms An optional array to push quads into instead of emitting them.\n   * @param reifier The reifier to emit this triple under.\n   */\n  protected emitTriple(subject: RDF.Quad_Subject, predicate: RDF.Quad_Predicate, object: RDF.Quad_Object,\n                       statementId?: RDF.NamedNode,\n                       childrenTripleTerms?: RDF.Quad[],\n                       reifier?: RDF.NamedNode | RDF.BlankNode) {\n    const quad = this.dataFactory.quad(subject, predicate, object, this.defaultGraph);\n    if (childrenTripleTerms) {\n      childrenTripleTerms.push(quad);\n    } else {\n      this.push(quad);\n    }\n    if (reifier) {\n      this.push(this.dataFactory.quad(reifier, this.dataFactory.namedNode(RdfXmlParser.RDF + 'reifies'), quad));\n    }\n\n    // Reify triple\n    if (statementId) {\n      this.push(this.dataFactory.quad(statementId,\n        this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'),\n        this.dataFactory.namedNode(RdfXmlParser.RDF + 'Statement'),\n        this.defaultGraph));\n      this.push(this.dataFactory.quad(statementId,\n        this.dataFactory.namedNode(RdfXmlParser.RDF + 'subject'), subject, this.defaultGraph));\n      this.push(this.dataFactory.quad(statementId,\n        this.dataFactory.namedNode(RdfXmlParser.RDF + 'predicate'), predicate, this.defaultGraph));\n      this.push(this.dataFactory.quad(statementId,\n        this.dataFactory.namedNode(RdfXmlParser.RDF + 'object'), object, this.defaultGraph));\n    }\n  }\n\n  /**\n   * Register the given term as a node ID.\n   * If one was already registered, this will emit an error.\n   *\n   * This is used to check duplicate occurrences of rdf:ID in scope of the baseIRI.\n   * @param {Term} term An RDF term.\n   */\n  protected claimNodeId(term: RDF.Term) {\n    if (!this.allowDuplicateRdfIds) {\n      if (this.nodeIds[term.value]) {\n        throw this.newParseError(`Found multiple occurrences of rdf:ID='${term.value}'.`);\n      }\n      this.nodeIds[term.value] = true;\n    }\n  }\n\n  /**\n   * Handle the given text string.\n   * @param {string} text A parsed text string.\n   */\n  protected onText(text: string) {\n    const activeTag: IActiveTag = this.activeTagStack.length\n      ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n\n    if (activeTag) {\n      if (activeTag.childrenStringTags) {\n        activeTag.childrenStringTags.push(text);\n      } else if (activeTag.predicate) {\n        activeTag.text = text;\n      }\n    }\n  }\n\n  /**\n   * Handle the closing of the last tag.\n   */\n  protected onCloseTag() {\n    const poppedTag: IActiveTag = this.activeTagStack.pop();\n    const parentTag: IActiveTag = this.activeTagStack.length\n        ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n\n    // If we were converting a tag to a string, and the tag was not self-closing, close it here.\n    if (poppedTag.childrenStringEmitClosingTag) {\n      poppedTag.childrenStringTags.push(poppedTag.childrenStringEmitClosingTag);\n    }\n\n    // Set the literal value if we were collecting XML tags to string\n    if (poppedTag.childrenTagsToString) {\n      poppedTag.datatype = this.dataFactory.namedNode(RdfXmlParser.RDF + 'XMLLiteral');\n      poppedTag.text = poppedTag.childrenStringTags.join('');\n      poppedTag.hadChildren = false; // Force a literal triple to be emitted hereafter\n    }\n\n    // Set the triple term value if we were collecting triple terms\n    if (poppedTag.childrenTagsToTripleTerms && poppedTag.predicate && poppedTag.rdfVersion) {\n      if (poppedTag.childrenTripleTerms.length !== 1) {\n        throw this.newParseError(`Expected exactly one triple term in rdf:parseType=\"Triple\" but got ${poppedTag.childrenTripleTerms.length}`);\n      }\n      for (const tripleTerm of poppedTag.childrenTripleTerms) {\n        this.emitTriple(poppedTag.subject, poppedTag.predicate, tripleTerm, null, parentTag.childrenTripleTerms, parentTag.reifier);\n      }\n      poppedTag.predicateEmitted = true;\n    }\n\n    if (poppedTag.childrenCollectionSubject) {\n      // Terminate the rdf:List\n      this.emitTriple(poppedTag.childrenCollectionSubject, poppedTag.childrenCollectionPredicate,\n        this.dataFactory.namedNode(RdfXmlParser.RDF + 'nil'), null, poppedTag.childrenTripleTerms);\n    } else if (poppedTag.predicate) {\n      if (!poppedTag.hadChildren && poppedTag.childrenParseType !== ParseType.PROPERTY) {\n        // Property element contains text\n        this.emitTriple(poppedTag.subject, poppedTag.predicate, this.createLiteral(poppedTag.text || '', poppedTag),\n          poppedTag.reifiedStatementId, poppedTag.childrenTripleTerms, poppedTag.reifier);\n      } else if (!poppedTag.predicateEmitted) {\n        // Emit remaining properties on an anonymous property element\n        const subject: RDF.Term = this.dataFactory.blankNode();\n        this.emitTriple(poppedTag.subject, poppedTag.predicate, subject, poppedTag.reifiedStatementId, poppedTag.childrenTripleTerms, poppedTag.reifier);\n        for (let i = 0; i < poppedTag.predicateSubPredicates.length; i++) {\n          this.emitTriple(subject, poppedTag.predicateSubPredicates[i], poppedTag.predicateSubObjects[i], null, poppedTag.childrenTripleTerms);\n        }\n      }\n    }\n  }\n\n  /**\n   * Fetch local DOCTYPE ENTITY's and make the parser recognise them.\n   * @param {string} doctype The read doctype.\n   */\n  protected onDoctype(doctype: string) {\n    doctype.replace(/<!ENTITY\\s+([^\\s]+)\\s+[\"']([^\"']+)[\"']\\s*>/g, (match, prefix, uri) => {\n      this.saxParser.ENTITIES[prefix] = uri;\n      return '';\n    });\n  }\n\n  private setDirection(activeTag: IActiveTag, value?: string) {\n    if (value) {\n      if (value !== 'ltr' && value !== 'rtl') {\n        throw this.newParseError(`Base directions must either be 'ltr' or 'rtl', while '${value}' was found.`);\n      }\n      activeTag.direction = value;\n    } else {\n      delete activeTag.direction;\n    }\n  }\n\n  private setVersion(activeTag: IActiveTag, version: string) {\n    activeTag.rdfVersion = version;\n    this.emit('version', version);\n  }\n}\n\nexport interface IRdfXmlParserArgs {\n  /**\n   * A custom RDFJS DataFactory to construct terms and triples.\n   */\n  dataFactory?: RDF.DataFactory;\n  /**\n   * An initital default base IRI.\n   */\n  baseIRI?: string;\n  /**\n   * The default graph for constructing quads.\n   */\n  defaultGraph?: RDF.Term;\n  /**\n   * If the internal position (line, column) should be tracked an emitted in error messages.\n   */\n  trackPosition?: boolean;\n  /**\n   * By default multiple occurrences of the same `rdf:ID` value are not allowed.\n   * By setting this option to `true`, this uniqueness check can be disabled.\n   */\n  allowDuplicateRdfIds?: boolean;\n  /**\n   * Enables validation of all URIs. Will throw an Error in case of an invalid URI.\n   * By default, it is equal to true.\n   */\n  validateUri?: boolean;\n  /**\n   * Allows to customize the used IRI validation strategy using the `IriValidationStrategy` enumeration.\n   * By default, the \"pragmatic\" strategy is used.\n   */\n  iriValidationStrategy?: IriValidationStrategy;\n}\n\nexport interface IActiveTag {\n  subject?: RDF.NamedNode | RDF.BlankNode;\n  predicate?: RDF.NamedNode;\n  predicateEmitted?: boolean;\n  predicateSubPredicates?: RDF.NamedNode[];\n  predicateSubObjects?: (RDF.NamedNode | RDF.BlankNode | RDF.Literal)[];\n  hadChildren?: boolean;\n  text?: string;\n  language?: string;\n  direction?: 'ltr' | 'rtl';\n  datatype?: RDF.NamedNode;\n  nodeId?: RDF.BlankNode;\n  childrenParseType?: ParseType;\n  baseIRI?: string;\n  listItemCounter?: number;\n  reifiedStatementId?: RDF.NamedNode;\n  childrenTagsToString?: boolean;\n  childrenStringTags?: string[];\n  childrenStringEmitClosingTag?: string;\n  // for creating rdf:Lists\n  childrenCollectionSubject?: RDF.NamedNode | RDF.BlankNode;\n  childrenCollectionPredicate?: RDF.NamedNode;\n  childrenTagsToTripleTerms?: boolean;\n  childrenTripleTerms?: RDF.Quad[];\n  reifier?: RDF.NamedNode | RDF.BlankNode;\n  rdfVersion?: string;\n  namespaces?: { key: string; value: string }[];\n}\n\nexport enum ParseType {\n  RESOURCE,\n  PROPERTY,\n}\n"]}